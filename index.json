[{"categories":["数学"],"content":"数学知识笔记","date":"2022-07-20","objectID":"/notes/","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"最近学到的数学知识笔记，如有谬误欢迎指正 :yum:。 ","date":"2022-07-20","objectID":"/notes/:0:0","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"ExGCD 用于解不定方程 $ax + by = \\gcd(a, b)$ 的一组整数解。 当 $b = 0$ 时，有一组解 $x = 1, y = 0$；我们研究能不能通过 $b, a \\bmod b$ 的一组解得到 $a, b$ 的一组解，因为如果能，那么我们可以在辗转相除的过程中推出 $x, y$。 由于 因此 得到 我们在辗转相除的递归过程中不断修改 $x, y$，最后得到要求的一组特解。 参考代码： int ExGcd(int a, int b, int \u0026x, int \u0026y) { if (b == 0) { x = 1, y = 0; return a; } int d = ExGcd(b, a % b, y, x); y -= a / b * x; return d; } 现在将问题扩展为求 $ax + by = c$ 的一组特解，根据 Bézout 定理，方程有解的充要条件是 $\\gcd(a, b) \\mid c$。如果有解，求出 $ax + bx = \\gcd(a, b)$ 的一组特解，然后 $x, y$ 同时乘 $\\frac {c} {\\gcd(a, b)}$ 即可。 ","date":"2022-07-20","objectID":"/notes/:1:0","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"CRT 用于解形式如下的线性同余方程组： 其中 $p$ 两两互质。 对于这样一个方程组，我们可以按如下流程构造出一个特解： 令 $P = \\prod p_i$； 由于 $p$ 两两互质，我们可以求出 $\\frac {P} {p_i}$ 在模 $p_i$ 意义下的逆元 $inv_i$； 令 $x_i = \\frac {P} {p_i} \\times inv_i$； $x = \\sum a_i x_i$。 这个构造是正确的，因为： $x_i$ 乘上 $a_i$， $x$ 是满足所有方程的一个特解。 现在要得到一个通解，$x$ 加上 $k$ 倍的 $\\mathrm{lcm}(p_1, p_2, \\dots, p_n)$ 即可，而 $p$ 两两互质，所以加上 $k$ 倍的 $P$ 就行了。 ","date":"2022-07-20","objectID":"/notes/:2:0","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"ExCRT 问题升级为不要求模数两两互质，也就是不一定有逆元了，因此我们采用将线性同余方程不断合并的方式，最后得到一个线性同余方程，用 ExGCD 求解（与 CRT 采用的构造法完全不同）。 将两个线性同余方程合并： 令 $x = k_1 p_1 + a_1 = k_2 p_2 + a_2$，得到 $k_2 p_2 - k_1 p_1 = a_1 - a_2$，这个方程符合 $ax + by = c$ 的形式，可以用 ExGCD 求解。得到 $k_1, k_2$ 后，随便代入一个方程，比如第一个，得到 $x = k_1 p_1 + a_1$，那么： 取模数为 $\\mathrm{lcm}(p_1, p_2)$ 的目的同样是把 $x$ 的特解转换成一个通解的形式，并保证余数不变。 不断重复合并的过程，最终得到一个线性同余方程： 时间复杂度 $\\mathrm{O}(n \\log_2 p)$。 ","date":"2022-07-20","objectID":"/notes/:2:1","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"BSGS 用于解高次同余方程 $a^x \\equiv b \\pmod p$（离散对数问题），其中 $(a, p) = 1$。 我们令 $m = \\sqrt p$，并令 $x = im - j$（用减法是为了后面不出现负号），那么原方程就变成了： 由于 $(a, p) = 1$，$a$ 存在模 $p$ 意义下的逆元，因此我们可以把 $a^{im - j}$ 拆了，并在两边同时乘 $a^j$，得到： 现在我们就避免了同时枚举两个数。分别枚举 $i, j$，一次枚举时将得到的值存表，另一次查表，就能得到满足条件的解。 求最小 / 最大解的方法 调整枚举顺序： 求最小解：先从小到大枚举 $j$（即存表时如果冲突，保留 $j$ 更大的），再从小到大枚举 $i$，找到就退出； 求最大解：先从大到小枚举 $j$（即存表时如果冲突，保留 $j$ 更小的），再从大到小枚举 $i$，找到就退出。 时间复杂度取决于表的实现，如果使用哈希表，则时间复杂度 $\\mathrm{O}(\\sqrt p)$，如果使用平衡树（std::map），则时间复杂度 $\\mathrm{O}(\\sqrt p \\log_2 p)$ 参考代码： int BSGS(int a, int b, int p) { if (1 % p == b % p) return 0; int k = std::sqrt(p) + 1; std::map\u003cint, int\u003e hash; for (int i = 0, j = b % p; i \u003c k; i++) { hash[j] = i; j = (long long)j * a % p; } int ak = 1; for (int i = 1; i \u003c= k; i++) ak = (long long)ak * a % p; for (int i = 1, j = ak; i \u003c= k; i++) { if (hash.count(j)) return (long long)i * k - hash[j]; j = (long long)j * ak % p; } return -PosInf; } ","date":"2022-07-20","objectID":"/notes/:3:0","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"ExBSGS 问题升级为不保证 $(a, p) = 1$，因此 $a$ 不一定存在模 $p$ 意义下的逆元。 为了解决这个问题，我们取 $d = \\gcd(a, p)$。如果 $d = 1$，则套用 BSGS 算法求解；否则在同余方程中将 $d$ 消去（如果 $d \\nmid b$，则无解），即： 再求 $d = \\gcd(a, \\frac p d)$，重复上述过程，直至 $d = 1$，即我们最终做 BSGS 的高次同余方程是： 但要注意，现在我们默认 $x \\ge k$ 了，但有可能 $x \u003c k$ 的时候有解。对于这个范围的 $x$，我们直接枚举求解（代入原方程），因为 $k$ 较小，因此并不会降低效率。 参考代码： int ExBSGS(int a, int b, int p) { b = (b % p + p) % p; if (1 % p == b % p) return 0; int x, y, d = ExGcd(a, p, x, y); if (d \u003e 1) { if (b % d != 0) return -PosInf; ExGcd(a / d, p / d, x, y); return ExBSGS(a, (long long)b / d * x % (p / d), p / d) + 1; } return BSGS(a, b, p); } ","date":"2022-07-20","objectID":"/notes/:3:1","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"特殊的 BSGS BSGS 还可以用来求解其它类型的简单高次方程，这里以矩阵为例： 只要矩阵 $A$ 有逆元（$A \\times A^{-1} = I$），我们可以完全套用 BSGS 的做法，只是将数改为矩阵（包括表中存储的内容）。 上述算法的一个应用是求 Fibonacci 数列在模 $p$ 意义下的最小循环节 $x$，即解这个方程： 令 $A = \\begin{bmatrix} 0 \u0026 1 \\cr 1 \u0026 1 \\end{bmatrix}$，我们发现 $A$ 存在逆元 $\\begin{bmatrix} -1 \u0026 1 \\cr 1 \u0026 0 \\end{bmatrix}$，可以通过上述方法求解，即代入做 BSGS 求最小解即得到最小循环节。 ","date":"2022-07-20","objectID":"/notes/:3:2","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"原根和阶 ","date":"2022-07-20","objectID":"/notes/:4:0","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"阶 (order) 对于一个数 $a$ 和模数 $p$，我们称最小的满足下面条件的数 $k$ 是 $a$ 模 $p$ 的阶：$a^k \\equiv 1 \\pmod p$，写作 $\\mathrm{ord}(a) = k$。 阶有一个性质：$\\mathrm{ord}(a) \\mid \\varphi(a)$，因为 $\\mathrm{ord}(a)$ 整除任意满足 $a^x \\equiv 1 \\pmod p$ 的数 $x$（可以利用 $x = k \\times \\mathrm{ord}(a) + r$ 证明出 $r = 0$），那么要求 $a$ 的阶就可以枚举 $\\varphi(a)$ 的因数。 ","date":"2022-07-20","objectID":"/notes/:4:1","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"原根 对于一个数 $p$，我们称一个满足下面条件的数 $g$ 是它的原根：$g^1, g^2, \\dots, g^{\\varphi(p)}$ 互不相同，且是 $1$ 到 $p - 1$ 中与 $p$ 互质的数的一个排列。 例如，$3$ 是 $998244353$ 的一个原根。 结合上面阶的定义，$p$ 的原根的阶是 $\\varphi(p)$，且阶为 $\\varphi(p)$ 的数是 $p$ 的原根。因此要判断一个数是不是原根，我们可以验证它的阶是不是 $\\varphi(p)$，但此时可以只枚举 $\\frac {\\varphi(p)} {x}$（$x$ 是 $p$ 的质因子，暂不能证明）。 经数学家证明，一个数如果存在原根，其最小原根是较小的，因此可以用枚举找原根。 ","date":"2022-07-20","objectID":"/notes/:4:2","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"筛法 如果要找一个范围内的质数，我们采用枚举每一个数并验证的方法是不好的，因为时间复杂度太高；但如果反过来，我们把不满足条件的删掉，就可以大大加速求解过程。 从 $2$ 开始枚举。当我们枚举到一个没有被标记的数时，我们确定它是一个质数；确定完一个数是不是质数后，我们标记它的倍数，流程如下： int primes[N], total; bool del[N]; void GetPrimes(int maxVal) { for (int i = 2; i \u003c= maxVal; i++) { if (!del[i]) primes[++total] = i; for (int j = 1; i * primes[j] \u003c= maxVal \u0026\u0026 j \u003c= total; j++) del[i * primes[j]] = true; } } 上面的过程叫 Eratosthenes 筛法，时间复杂度 $\\mathrm{O}(n \\log_2 \\log_2 n)$。我们发现时间复杂度的瓶颈在于一个数会被多个数标记，但我们希望一个数只被筛一次，因此我们规定：一个数只被它的最小质因子筛掉，于是有了下面的流程： int primes[N], total; bool del[N]; void GetPrimes(int maxVal) { for (int i = 2; i \u003c= maxVal; i++) { if (!del[i]) primes[++total] = i; for (int j = 1; i * primes[j] \u003c= maxVal \u0026\u0026 j \u003c= total; j++) { del[i * primes[j]] = true; if (i % primes[j] == 0) break; } } } 增加的两行代码完成了这样一个事情：枚举 $\\mathrm{primes}_j$ 就是在枚举最小质因子，一旦发现 $i$ 中包含了 $i \\times \\mathrm{primes}_j$ 的最小质因子 $\\mathrm{primes}_j$，那么说明后面的数中 $\\mathrm{primes}_j$ 不再是它们的最小质因子，因此直接退出。可以证明这样会不重不漏地筛掉所有合数（我证不来，欢迎指教）。这个过程叫线性筛，时间复杂度 $\\mathrm{O}(n)$。 ","date":"2022-07-20","objectID":"/notes/:5:0","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"线性筛筛积性函数 由于积性函数 $f$ 满足 $\\forall \\gcd(x, y) = 1, f(xy) = f(x) f(y)$，那么对于一个数 $n = \\prod p_i^{c_i}$，我们只需要知道每一个 $p_i^{c_i}$ 的函数值，就能得到 $n$ 的函数值，因此我们对线性筛的过程进行扩充，记录 $g_i$ 表示 $i$ 的最小质因子对应的幂（即 $p_1^{c_1}$），然后分类讨论求 $g_i$： 如果 $i$ 是质数，那么 $g_i = i$； 如果 $\\mathrm{primes}_j \\mid i$，说明应当累计 $i \\times \\mathrm{primes}j$ 的最小质因子，那么 $g{i \\times \\mathrm{primes}_j} = g_i \\times \\mathrm{primes}_j$； 如果 $\\mathrm{primes}_j \\nmid i$，说明枚举到了 $i \\times \\mathrm{primes}j$ 的最小质因子，那么 $g{i \\times \\mathrm{primes}_j} = \\mathrm{primes}_j$。 现在得到了 $g_i$，那么求 $f(i)$ 的过程也可以分类讨论： 如果 $g_i = i$，说明 $i$ 是质数，按 $f$ 的定义直接求（数论函数一般在质数上的函数值都很好求，因为因子只有 $1$ 和自己）； 如果 $\\mathrm{primes}_j \\nmid i$，那么它们互质，可以根据积性函数的性质，$f(i \\times \\mathrm{primes}_j) = f(i) \\times f(\\mathrm{primes}_j)$； 如果 $\\mathrm{primes}_j \\mid i$，我们继续讨论： 如果 $g_i = i$，那么这是两个质数相乘的情况，直接求； 否则说明是往 $i$ 上累加一个质数 $\\mathrm{primes}_j$，我们调整成两个质数的函数值相乘的情况，即 $f(i \\times \\mathrm{primes}_j) = f(\\frac {i} {g_i}) \\times f(g_i \\times \\mathrm{primes}_j)$。 现在我们以 $f = \\mu * \\mathrm{id}_k$ 的求值为例，参考代码： int f[N + 5], g[N + 5]; int primes[N + 5], total; void GetPrimes(int maxVal) { f[1] = g[1] = 1; for (int i = 2; i \u003c= maxVal; i++) { if (g[i] == 0) { primes[++total] = i; f[i] = FastPow(i, K) - 1; g[i] = i; } for (int j = 1; i * primes[j] \u003c= maxVal; j++) { if (i % primes[j] == 0) { if (g[i] == i) // p^{nk} * (p^k - 1). f[i * primes[j]] = (long long)f[i] * (f[primes[j]] + 1) % MOD; else f[i * primes[j]] = (long long)f[i / g[i]] * f[primes[j] * g[i]] % MOD; g[i * primes[j]] = g[i] * primes[j]; break; } f[i * primes[j]] = (long long)f[i] * f[primes[j]] % MOD; g[i * primes[j]] = primes[j]; } } } 对于一些特殊的积性函数（如 $\\varphi$，$\\mu$），我们不必这么麻烦，可以利用它自己的特殊性质，修改线性筛的过程求值。 ","date":"2022-07-20","objectID":"/notes/:5:1","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"杜教筛 有时我们不需要得到积性函数的值，而是它的前缀和，在线性筛 $\\mathrm{O}(n)$ 的基础上，杜教筛可以在 $\\mathrm{O}(n^{\\frac 2 3})$ 的时间内求得积性函数的前缀和。 令 $s(n) = \\sum_{i = 1}^n f(i)$，若 $f * g = h$，那么： 移项后得到： 如果 $g, h$ 的前缀和很好算，那么 $s(n)$ 就好求了。常见的 $f * g = h$ 有 $\\mu * \\mathrm{I} = \\epsilon$，$\\varphi * \\mathrm{I} = \\mathrm{id}$，$\\mathrm{id} * \\mu = \\varphi$（$\\mathrm{I}, \\mathrm{id}$ 的前缀和都很好算）。 具体流程：先线性筛预处理 $f$ 的前 $\\mathrm{O}(\\sqrt n)$ 项，再递归实现上述过程，并用一个表存储 $s$ 的值。 下面以求 $\\mu, \\varphi$ 的前缀和为例（洛谷 P4213 【模板】杜教筛（Sum）），参考代码： #include \u003ciostream\u003e#include \u003cmap\u003e const int M = 1e6; struct Info { long long mu, phi; Info() { mu = phi = 0; } Info(long long _mu, long long _phi) : mu(_mu), phi(_phi) {} Info operator+(const Info \u0026x) const { return {mu + x.mu, phi + x.phi}; } Info operator-(const Info \u0026x) const { return {mu - x.mu, phi - x.phi}; } Info operator*(const long long x) const { return {mu * x, phi * x}; } } val[M + 5], bSum[M + 5]; int primes[M + 5], total; bool del[M + 5]; std::map\u003clong long, Info\u003e sum; void GetPrimes(int maxVal) { val[1].phi = val[1].mu = 1; for (int i = 2; i \u003c= maxVal; i++) { Info \u0026u = val[i]; if (!del[i]) { primes[++total] = i; u.mu = -1; u.phi = i - 1; } for (int j = 1; i * primes[j] \u003c= maxVal; j++) { del[i * primes[j]] = true; Info \u0026v = val[i * primes[j]]; if (i % primes[j] == 0) { v.phi = u.phi * primes[j]; v.mu = 0; break; } v.phi = u.phi * (primes[j] - 1); v.mu = -u.mu; } } bSum[1] = val[1]; for (int i = 2; i \u003c= maxVal; i++) bSum[i] = bSum[i - 1] + val[i]; } Info GetSum(long long x) { if (x \u003c= M) return bSum[x]; if (sum.count(x) \u003e 0) return sum[x]; Info res(0, 0); res.mu = 1, res.phi = (long long)x * (x + 1) / 2; for (long long l = 2, r = 0; l \u003c= x \u0026\u0026 r \u003c= x; l = r + 1) { r = x / (x / l); res = res - GetSum(x / l) * (r - l + 1); } sum[x] = res; return res; } int main() { std::ios::sync_with_stdio(false); int T, n; std::cin \u003e\u003e T; GetPrimes(M); for (int test = 1; test \u003c= T; test++) { std::cin \u003e\u003e n; Info res = GetSum(n); std::cout \u003c\u003c res.phi \u003c\u003c ' ' \u003c\u003c res.mu \u003c\u003c '\\n'; } return 0; } ","date":"2022-07-20","objectID":"/notes/:5:2","tags":["数学"],"title":"数学知识笔记","uri":"/notes/"},{"categories":["数学"],"content":"肤浅地认识下矩阵 至少从表面上看，矩阵是一个二维数组。矩阵的加减法就是在相同的位置上进行加减，即： $$ C_{i, j} = A_{i, j} \\pm B_{i, j} $$ 其中矩阵 $A$，$B$ 和 $C$ 的行数和列数都是相同的。 而矩阵的乘法显得有些不同，如果 $A$ 是 $n \\times m$ 矩阵，$B$ 是 $m \\times p$ 矩阵，那么 $C = A \\times B$ 是 $n \\times p$ 矩阵，且： $$ C_{i, j} = \\sum_{k = 1}^m A_{i, k} \\times B_{k, j} $$ 和加减法相同位置操作不同，$C$ 中每个数 $x$ 是由 $A$ 中与 $x$ 同行的数和 $B$ 中与 $x$ 同列的数相乘的和，这实际上是在体现一种变换，把 $A$ 的一行看作一个向量（可以先理解成一行数，并把某一列的数称作某一维的数），那么 $A \\times B$ 就是让 $A$ 中某一行的一个向量按照矩阵 $B$ 所体现的变换规则变换成另一个向量，因此让每一维的数去乘 $B$ 中每一维所需变换的值，就比较有道理了（由于本人水平太低，没法解释得很清楚，建议阅读神犇孟岩老师的 理解矩阵）。 而我们利用矩阵乘法，正是通过构造矩阵来体现变换，从而实现一维状态的递推。而矩阵乘法满足交换律，这使得我们在需要多次递推时，将快速幂应用于矩阵乘法中，从而加速递推。 ","date":"2022-03-18","objectID":"/matrix/:1:0","tags":["数学"],"title":"矩阵乘法及应用","uri":"/matrix/"},{"categories":["数学"],"content":"两个例题 ","date":"2022-03-18","objectID":"/matrix/:2:0","tags":["数学"],"title":"矩阵乘法及应用","uri":"/matrix/"},{"categories":["数学"],"content":"AcWing-205-斐波那契 本题是经典的求斐波那契数列第 $n$ 项的问题，但数据范围扩大到了 $10 ^ 9$，并且有多组数据，$O(n)$ 是会超时的。结合前面提到的矩阵，我们可以思考如何将斐波那契数列递推公式 $f_i = f_{i - 1} + f_{i - 2}$ 转换为向量 $f$ 与矩阵 $A$ 相乘的形式。 由于某一项实际上只与前两项相关，我们只需要在向量 $f$ 中保留两项，即 $f = (f_{i - 1}, f_i)$，这时我们要造出下一个 $f = (f_i, f_{i + 1})$，那么新的 $f$ 中第二个位置应当是原 $f$ 中两个数的和，为了保留它们，我们把 $A$ 的第二列构造为 $1$；而 $f$ 中第一个位置只需要保留原 $f$ 中的后一项，因此我们把 $A$ 的第一列构造为 $(0, 1)$，这样，原来的递推过程转化为了： $$ f' = f \\times \\begin{pmatrix} 0 \u0026 1 \\cr 1 \u0026 1 \\end{pmatrix} $$ 这样我们可以对上述公式应用快速幂：矩阵乘法是 $O(n ^ 3)$ 的，在本题中 $n = 2$，复杂度为常数，因此总共的时间复杂度是 $O(\\log_2 n)$，可以通过本题。 参考代码： #include \u003ciostream\u003e class Matrix { public: const static int N = 5, MOD = 10000; int val[N][N], line, col; Matrix(int line, int col) : line(line), col(col) { for (int i = 0; i \u003c line; i++) for (int j = 0; j \u003c col; j++) val[i][j] = 0; } // Matrix operator+(const Matrix\u0026 mat) const // { // if (line != mat.line || col != mat.col) // return Matrix(0, 0); // Matrix res(line, col); // for (int i = 0; i \u003c line; i++) // for (int j = 0; j \u003c col; j++) // res.val[i][j] = ((long long)val[i][j] + mat.val[i][j]) % MOD; // return res; // } // Matrix operator-(const Matrix\u0026 mat) const // { // if (line != mat.line || col != mat.col) // return Matrix(0, 0); // Matrix res(line, col); // for (int i = 0; i \u003c line; i++) // for (int j = 0; j \u003c col; j++) // res.val[i][j] = ((long long)val[i][j] - mat.val[i][j]) % MOD; // return res; // } Matrix operator*(const Matrix\u0026 mat) const { if (col != mat.line) return Matrix(0, 0); Matrix res(line, mat.col); for (int i = 0; i \u003c line; i++) for (int j = 0; j \u003c mat.col; j++) for (int k = 0; k \u003c col; k++) res.val[i][j] = ((long long)res.val[i][j] + (long long)val[i][k] * mat.val[k][j]) % MOD; return res; } Matrix operator^(int k) const { if (line != col) return Matrix(0, 0); Matrix res(line, col), mat = (*this); for (int i = 0; i \u003c line; i++) res.val[i][i] = 1; while (k \u003e 0) { if (k \u0026 1) res = (res * mat); mat = (mat * mat); k \u003e\u003e= 1; } return res; } }; int n; Matrix f(1, 2), A(2, 2); int main() { while (true) { std::cin \u003e\u003e n; if (n == -1) return 0; f.val[0][0] = 0, f.val[0][1] = 1; A.val[0][0] = 0, A.val[0][1] = 1, A.val[1][0] = 1, A.val[1][1] = 1; A = (A ^ n); f = (f * A); std::cout \u003c\u003c f.val[0][0] \u003c\u003c std::endl; } return 0; } ","date":"2022-03-18","objectID":"/matrix/:2:1","tags":["数学"],"title":"矩阵乘法及应用","uri":"/matrix/"},{"categories":["数学"],"content":"AcWing-206-石头游戏 现在是一个二维的棋盘了，是不是就不符合前面所说的一维递推了呢？确实，但是我们发现 $0 \\le m, n \\le 8$，因此可以采用二维化一维，即令 $\\mathrm{Index}(x, y) = (x - 1) \\times m + y$，给每个坐标一个一维的数字编号。 这时题目中的变换就不难构造了。首先，上下左右的移动，以向上为例，可以设置变换矩阵 $A$ 的第 $\\mathrm{Index}(x, y)$ 行，第 $\\mathrm{Index}(x - 1, y)$ 列（$x \u003e 1$）为 $1$。 那么添加石头呢？我们需要一个不与其它坐标冲突的位置作为石头来源，这里让 $A_{0, 0}$ 为 $1$，为其它格子提供石头。如果要放 $i$ 个石头，就让 $A$ 的第 $0$ 行，第 $\\mathrm{Index}(x, y)$ 列为 $i$。同时，为了保证原来的石头还在，$A$ 的第 $\\mathrm{Index}(x, y)$ 行，第 $\\mathrm{Index}(x, y)$ 列应当为 $1$。 $A$ 的其它位置均设置为 $0$。 这时仔细想想会发现，丢弃石头其实不需要考虑，因为只有上面两类变换保留了石头。 不过本题还有一个时间维度，只需要构造多个矩阵满足不同时刻的变换即可。这里有一个偷懒的地方：由于操作序列长度不超过 $6$，所有长度的最小公倍数最大就是 $60$，所以把前 $60$ 个时刻的变换矩阵求出来，后面一定都是可以复用的，省去了求最小公倍数的步骤。 最后，使用快速幂加速递推，我们便可以通过本题。 要特别注意的是：矩阵中的“$1$”（单位矩阵，只对于行数和列数相同的有定义）不是全为 $0$ 的矩阵，而是主对角线（左上到右下）为 $1$ 的矩阵（意义是保留向量每一维上的原有值），千万不要忘记初始化了。 参考代码： #include \u003ciostream\u003e const int N = 8 + 5, K = 60; class Matrix { public: const static int L = N * N; int line, col; long long val[L][L]; Matrix() {} Matrix(int line, int col) : line(line), col(col) { for (int i = 0; i \u003c line; i++) for (int j = 0; j \u003c col; j++) val[i][j] = 0; } Matrix operator*(const Matrix\u0026 mat) const { if (col != mat.line) return Matrix(0, 0); Matrix res(line, mat.col); for (int i = 0; i \u003c line; i++) for (int j = 0; j \u003c mat.col; j++) for (int k = 0; k \u003c col; k++) res.val[i][j] += val[i][k] * mat.val[k][j]; return res; } Matrix operator^(int k) const { if (line != col) return Matrix(0, 0); Matrix res(line, col), mat = (*this); for (int i = 0; i \u003c line; i++) res.val[i][i] = 1; while (k \u003e 0) { if (k \u0026 1) res = (res * mat); mat = (mat * mat); k \u003e\u003e= 1; } return res; } }; int n, m, len, T, act; int opt[N][N]; Matrix trans[K + 5], transd, f; std::string op[N]; inline int GetIndex(int x, int y) { return (x - 1) * n + y; } void Init() { transd = Matrix(len + 1, len + 1); f = Matrix(1, len + 1); f.val[0][0] = 1; // 周期最大就是 60，懒得求最小公倍数了。 for (int ts = 0; ts \u003c K; ts++) { trans[ts] = Matrix(len + 1, len + 1); trans[ts].val[0][0] = 1; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) { int pos = GetIndex(i, j); std::string\u0026 lop = op[opt[i][j]]; char sop = lop[ts % lop.length()]; if (sop \u003e= '0' \u0026\u0026 sop \u003c= '9') { trans[ts].val[0][pos] = sop - '0'; trans[ts].val[pos][pos] = 1; } else if (sop == 'N' \u0026\u0026 i \u003e 1) trans[ts].val[pos][GetIndex(i - 1, j)] = 1; else if (sop == 'S' \u0026\u0026 i \u003c n) trans[ts].val[pos][GetIndex(i + 1, j)] = 1; else if (sop == 'W' \u0026\u0026 j \u003e 1) trans[ts].val[pos][GetIndex(i, j - 1)] = 1; else if (sop == 'E' \u0026\u0026 j \u003c m) trans[ts].val[pos][GetIndex(i, j + 1)] = 1; } } } long long Solve() { int r = T % K; int d = T / K; // 一定要初始化 transd，否则乘出来都是 0。 for (int i = 0; i \u003c= len; i++) transd.val[i][i] = 1; for (int ts = 0; ts \u003c K; ts++) transd = transd * trans[ts]; f = f * (transd ^ d); for (int ts = 0; ts \u003c r; ts++) f = f * trans[ts]; long long res = 0; for (int i = 1; i \u003c= len; i++) res = std::max(res, f.val[0][i]); return res; } int main() { std::ios::sync_with_stdio(false); std::cin \u003e\u003e n \u003e\u003e m \u003e\u003e T \u003e\u003e act; len = n * m; for (int i = 1; i \u003c= n; i++) { std::string str; std::cin \u003e\u003e str; for (int j = 1; j \u003c= m; j++) opt[i][j] = str[j - 1] - '0'; } for (int i = 0; i \u003c act; i++) std::cin \u003e\u003e op[i]; Init(); std::cout \u003c\u003c Solve() \u003c\u003c std::endl; return 0; } ","date":"2022-03-18","objectID":"/matrix/:2:2","tags":["数学"],"title":"矩阵乘法及应用","uri":"/matrix/"},{"categories":["字符串","动态规划"],"content":"Z 函数 （以下默认字符串下标从0开始）。 在 KMP 字符串匹配算法中，使用了$\\pi$来表示一个字符串的最长公共前后缀，现在我们介绍一个与公共前缀有关的函数，Z 函数。我们用$z_i$表示一个字符串与它以$i$为起点的后缀的最长公共前缀（LCP）。此外，定义$z_0$为$0$。例如，字符串abcabca的$z$值分别为$0, 0, 0, 4, 0, 0, 1$。 ","date":"2021-11-17","objectID":"/z-algorithm/:1:0","tags":["字符串","动态规划"],"title":"Z 函数及其求法（扩展 KMP）","uri":"/z-algorithm/"},{"categories":["字符串","动态规划"],"content":"Z 函数的求法 根据 Z 函数的定义，我们可以枚举待求字符串的的每一个后缀，从头开始尝试匹配，得到 Z 函数的值。这样计算的时间复杂度是$O(n^2)$。 参考代码（std::string，字符串下标从0开始）： void GetZFunc(const std::string str) { int len = str.length(); for (int i = 1; i \u003c len; i++) while (i + z[i] \u003c len \u0026\u0026 str[z[i]] == str[i + z[i]]) z[i]++; return; } ","date":"2021-11-17","objectID":"/z-algorithm/:2:0","tags":["字符串","动态规划"],"title":"Z 函数及其求法（扩展 KMP）","uri":"/z-algorithm/"},{"categories":["字符串","动态规划"],"content":"Z 算法（在$O(n)$时间内求出 Z 函数） 类似 KMP 字符串匹配中求$\\pi$和 Manacher 算法中求最长回文时的优化思路，我们来想一想能不能利用已有信息减少暴力匹配的计算次数。 为了方便解释，我们把与$s_0 \\dots s_{z_i}$匹配的子串$s_i \\dots s_{i + z_i - 1}$称为“匹配子串”。我们计算 Z 的时候记录右端点最靠右的“匹配子串”$s_l \\dots s_r$，这时如果$i \\le r$，那么$s_i \\dots s_r$一定与$s_{i - l} \\dots s_{r - l}$相同。此时$z_{i - l}$与$z_i$是相同的。但要注意，如果$z_{i - l} \\ge r - i + 1$，那么不能保证$r$后面的字符和$r - l$后面的字符匹配，需要暴力尝试。 如果$i \\ge r$，由于没有已知信息可以利用，也需要暴力尝试。 以上过程可以用下面的图表示： \\rlap{ \\underbrace{ \\phantom{ s_0 \\dots s_{i - l} \\dots s_i \\dots s_{r - l} \\dots} }_\\text{same} } s_0 \\dots s_{i - l} \\dots \\overbrace{ s_l \\dots s_i \\dots s_{r - l} \\dots s_r }^\\text{same} \\dots 由于$r$只增不减，Z 算法的时间复杂度为$O(n)$。 参考代码（std::string，字符串下标从0开始）： void ZAlgorithm(const std::string \u0026str) { int len = str.length(); z[0] = 0; for (int i = 1, l = 0, r = 0; i \u003c len; i++) { int k = z[i - l]; if (i \u003c= r \u0026\u0026 k \u003c r - i + 1) z[i] = k; else { k = std::max(r - i + 1, 0); while (i + k \u003c len \u0026\u0026 str[i + k] == str[k]) k++; z[i] = k; } if (i + k - 1 \u003e r) { l = i; r = i + k - 1; } } } ","date":"2021-11-17","objectID":"/z-algorithm/:3:0","tags":["字符串","动态规划"],"title":"Z 函数及其求法（扩展 KMP）","uri":"/z-algorithm/"},{"categories":["字符串","动态规划"],"content":"Z 算法的扩展 有些时候，我们需要求某个字符串与另一个字符串后缀的最长公共前缀，该问题的解决方法同上，只是匹配时不再进行自身比较，而是文本串（的后缀）和模式串进行比较。 但要注意三个细节： 仍然要取z[i - l]（这意味着要先对文本串做 Z 算法）。因为上面用于加速算法的性质是针对一个字符串的，不能用新的代替。 匹配时注意边界，文本串和模式串都要判断。 单独处理$z_0$。单个字符串与自己的最大公共前缀一定是它的长度（Z 函数中只是定义为$0$）扩展处理时如果不定义$z_0 = 0$，应当从头枚举计算$z_0$。 参考代码（std::string，字符串下标从0开始）： // `prev` means the `z` of `text`. void ExZAlgorithm(const std::string \u0026text, const std::string \u0026pattern) { int tLen = text.length(), pLen = pattern.length(); z[0] = 0; for (int i = 0; i \u003c std::min(tLen, pLen); i++) { if (text[i] == pattern[i]) z[0]++; else break; } for (int i = 1, l = 0, r = 0; i \u003c tLen; i++) { int k = prev[i - l]; // not `z`. if (i \u003c= r \u0026\u0026 k \u003c r - i + 1) z[i] = k; else { k = std::max(r - i + 1, 0); while (i + k \u003c tLen \u0026\u0026 k \u003c pLen \u0026\u0026 text[i + k] == pattern[k]) k++; z[i] = k; } if (i + k - 1 \u003e r) { l = i; r = i + k - 1; } } } ","date":"2021-11-17","objectID":"/z-algorithm/:3:1","tags":["字符串","动态规划"],"title":"Z 函数及其求法（扩展 KMP）","uri":"/z-algorithm/"},{"categories":["字符串","动态规划"],"content":"回文字符串及回文中心表示法 形如$s_0, s_1, \\dots,s_{i - 1}, s_i, s_{i - 1} \\dots, s_1, s_0$或$s_0, s_1, \\dots, s_i, s_i \\dots, s_1, s_0$的，正着写和倒着写相同的字符串叫做**回文字符串**。abcba、aabbaa、c都是回文字符串。如果一个字符串的子串正着写和倒着写相同，这个字串叫做**回文子串**。 ","date":"2021-11-16","objectID":"/palindrome-and-manacher-algorithm/:1:0","tags":["字符串","动态规划"],"title":"回文字符串和 Manacher 算法","uri":"/palindrome-and-manacher-algorithm/"},{"categories":["字符串","动态规划"],"content":"回文中心表示法 用$d_i$表示从$s_i$到以它为回文中心的回文子串的边界的最长距离（包括$s_i$）。最长距离意味着边界以内的部分也是回文子串。 例如，abcba的$d$可以表示为$1, 1, 3, 1, 1$。 ","date":"2021-11-16","objectID":"/palindrome-and-manacher-algorithm/:1:1","tags":["字符串","动态规划"],"title":"回文字符串和 Manacher 算法","uri":"/palindrome-and-manacher-algorithm/"},{"categories":["字符串","动态规划"],"content":"求一个字符串的所有$d$ 首先可以以每一个点为中心向外拓展，因为枚举每一个点的复杂度是$O(n)$，向外拓展的复杂度也是$O(n)$，因此这样做的时间复杂度是$O(n^2)$。 如果字符串下标从0开始，代码可以这样写： for (int i = 0; i \u003c n; i++) { d[i] = 1; while (0 \u003c= i - d[i] \u0026\u0026 i + d[i] \u003c n \u0026\u0026 str[i - d[i]] == str[i + d[i]]) d[i]++; } 你可能已经注意到上面的代码处理不了回文中心为空的情况，我们待会儿来考虑这个（因为可以通过插入字符的方法将它转化为回文中心不为空的情况）。 ","date":"2021-11-16","objectID":"/palindrome-and-manacher-algorithm/:2:0","tags":["字符串","动态规划"],"title":"回文字符串和 Manacher 算法","uri":"/palindrome-and-manacher-algorithm/"},{"categories":["字符串","动态规划"],"content":"Manacher 算法 现在要给这个过程加速，我们来看看能不能利用已知信息。 如果待求点$i$前面有回文子串的最右端点$r$大于$i$，我们把这个回文子串的回文中心记为$t$，最左端点记为$l$，最右端点记为$r$，那么$s_t \\dots s_i$这一段必然可以以$t$为中心向前面翻折，$i$的对应位置记为$j$，相应的，以$j$为中心的回文子串也与以$i$为中心的回文子串关于$t$对称，那么此时可以确定的$d_i$大小就是$d_j$。当然，以上的结论还有一个限制：以$j$为中心的回文子串的左端点不能超过以$t$为中心的回文子串的左端点$l$，因为不能保证$l$左边仍然可以和$r$右边关于$t$对称。因此我们要设置一个$d_i$转移时的最大值。这个过程可以用下图表示（$\\LaTeX$来源：OI Wiki）： 那么$r$右边的部分呢？这时可以用上面的办法向外拓展，最后更新回文子串的最右端点。 由于端点$r$只增不减（类似KMP字符串匹配的原理），该算法的时间复杂度为$O(n)$。 本算法由Glenn K. Manacher（不是Face Off里的Glenn）发明。 参考代码（以0为字符串下标起点）： for (int i = 0, l = 0, r = -1; i \u003c len; i++) { int k = 1; // `r - i + 1` is the limit. if (i \u003c= r) k = std::min(d[l + r - i], r - i + 1); // `i - k` and `i + k` are the next positions. while (i - k \u003e= 0 \u0026\u0026 i + k \u003c len \u0026\u0026 str[i - k] == str[i + k]) k++; d[i] = k; if (i + k - 1 \u003e r) { l = i - k + 1; r = i + k - 1; } } 如果字符串下标从1开始，需要做一点调整： for (int i = 1, l = 1, r = 0; i \u003c= n; i++) { int k = 1; if (i \u003c= r) k = std::min(d[l + r - i], r - i + 1); while (i - k \u003e= 1 \u0026\u0026 i + k \u003c= n \u0026\u0026 str[i - k] == str[i + k]) k++; d[i] = k; if (i + k - 1 \u003e r) { l = i - k + 1; r = i + k - 1; } } ","date":"2021-11-16","objectID":"/palindrome-and-manacher-algorithm/:3:0","tags":["字符串","动态规划"],"title":"回文字符串和 Manacher 算法","uri":"/palindrome-and-manacher-algorithm/"},{"categories":["字符串","动态规划"],"content":"回文中心为空的处理办法 我们不想给回文中心为空单独添加一份代码，因此可以在原字符串每个字符之间和首尾添加一个特殊的字符（比如#），此时原字符数$n$，添加字符数$n + 1$，新字符串的字符数$2n + 1$，一定是一个奇数。此时回文子串一定每个$d$值减去$1$就是整个回文子串的真正长度（#其实代表了字符间的空位）。 添字处理参考代码（C风格字符串，下标从1开始）： int initLen = std::strlen(initial + 1); for (int i = 1; i \u003c= initLen; i++) { str[++n] = '#'; str[++n] = initial[i]; } str[++n] = '#'; str[++n] = '\\0'; // `n` stands for the length of `str`. 使用std::string（下标从0开始）的参考代码： const std::string unit(\"#\"); int tLen = initial.length(); for (int i = 0; i \u003c tLen; i++) str.append(unit + initial[i]); str.append(unit); ","date":"2021-11-16","objectID":"/palindrome-and-manacher-algorithm/:3:1","tags":["字符串","动态规划"],"title":"回文字符串和 Manacher 算法","uri":"/palindrome-and-manacher-algorithm/"},{"categories":["动态规划"],"content":"问题简介 需要用动态规划解决的问题被搬到了树上（不再是线性或区间的），此类问题与其他的区别仅仅在于遍历所有状态需要在树上进行，而不是用一个循环。 ","date":"2021-10-18","objectID":"/tree-dp/:1:0","tags":["动态规划"],"title":"树形动态规划","uri":"/tree-dp/"},{"categories":["动态规划"],"content":"例题 ","date":"2021-10-18","objectID":"/tree-dp/:2:0","tags":["动态规划"],"title":"树形动态规划","uri":"/tree-dp/"},{"categories":["动态规划"],"content":"AcWing-1072-树的最长路径 树的直径：树上距离最远的两个点。 方法一：两次搜索 任取一个点，找到与这个点距离最远的点$u$，然后从$u$出发，找到与$u$距离最远的点$v$，$u \\rightarrow v$就是直径。可以用反证法证明。 方法二：树形动态规划 以一个点为根，将这棵树提起来，根向下找到路径长的最大值$d1$，和路径长的次大值$d2$，直径就是以各个点为根产生的$d1 + d2$的最大值。 #include \u003ciostream\u003e const int N = 500005, M = N \u003c\u003c 1; int n, diam = 0; int head[N], total; struct Edge { int to, w; int next; } edges[M]; void Add(int a, int b, int c) { edges[total].to = b; edges[total].w = c; edges[total].next = head[a]; head[a] = total++; } int Search(int u, int parent) { int d1 = 0, d2 = 0; for (int i = head[u]; i != -1; i = edges[i].next) { int v = edges[i].to, w = edges[i].w; if (v == parent) continue; int d = Search(v, u) + w; if (d \u003e= d1) { d2 = d1; d1 = d; } else if (d \u003e d2) d2 = d; } diam = std::max(diam, d1 + d2); return d1; } int main() { for (int i = 0; i \u003c N; i++) head[i] = -1; std::cin \u003e\u003e n; for (int i = 1; i \u003c= n - 1; i++) { int a, b, c; std::cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; Add(a, b, c); Add(b, a, c); } Search(1, 0); std::cout \u003c\u003c diam \u003c\u003c std::endl; return 0; } ","date":"2021-10-18","objectID":"/tree-dp/:2:1","tags":["动态规划"],"title":"树形动态规划","uri":"/tree-dp/"},{"categories":["动态规划"],"content":"LibreOJ-10155-数字转换 数字间的转换可以看作节点之间的连接。由于一个数$u$的约数之和$v$只有一个确定的值，我们可以把$v$构造成$u$的父节点。最长的转换就是树的最长路径。 求约数之和时为了快，可以反向求（先找约数是哪些数的约数，再构造数），这样时间复杂度就从$O(n \\sqrt n)$降至$O(n \\ln n)$。 #include \u003ciostream\u003e const int N = 50005, PosInf = 1e9; struct Edge { int to, next; } edges[N]; int n, head[N], total, ans = -PosInf; int sum[N]; // 约数之和 bool hasParent[N]; void Add(int a, int b) { Edge \u0026e = edges[total]; e.to = b; e.next = head[a]; head[a] = total++; } void Init() { for (int i = 1; i \u003c= n; i++) for (int j = 2; j \u003c= n / i; j++) // 用n / i防止溢出 sum[i * j] += i; for (int i = 0; i \u003c N; i++) head[i] = -1; for (int i = 2; i \u003c= n; i++) if (i \u003e sum[i]) { Add(sum[i], i); hasParent[i] = true; } } int Search(int u) { int d1 = 0, d2 = 0; for (int i = head[u]; i != -1; i = edges[i].next) { int v = edges[i].to; int dis = Search(v) + 1; if (dis \u003e= d1) { d2 = d1; d1 = dis; } else if (dis \u003e d2) d2 = dis; } ans = std::max(ans, d1 + d2); return d1; } int main() { std::cin \u003e\u003e n; Init(); for (int i = 1; i \u003c= n; i++) if (!hasParent[i]) Search(i); std::cout \u003c\u003c ans \u003c\u003c std::endl; return 0; } ","date":"2021-10-18","objectID":"/tree-dp/:2:2","tags":["动态规划"],"title":"树形动态规划","uri":"/tree-dp/"},{"categories":["动态规划"],"content":"洛谷-P2015-二叉苹果树 本题类似有依赖的背包问题，用$f_{i, j}$表示在以$i$为根的子树中选$j$个树枝的最大价值。 #include \u003ciostream\u003e const int N = 105, M = 205; struct Edge { int to, w; int next; } edges[M]; int n, m; int head[N], total; int f[N][N]; void Add(int a, int b, int c) { Edge \u0026e = edges[total]; e.to = b; e.w = c; e.next = head[a]; head[a] = total++; } void Search(int u, int parent) { for (int i = head[u]; i != -1; i = edges[i].next) // 分组 { int v = edges[i].to; if (v == parent) continue; Search(v, u); for (int j = m; j \u003e= 0; j--) // 体积 for (int k = 0; k \u003c j; k++) // 决策 f[u][j] = std::max(f[u][j], f[u][j - k - 1] + f[v][k] + edges[i].w); } } int main() { for (int i = 0; i \u003c N; i++) head[i] = -1; std::cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n - 1; i++) { int a, b, c; std::cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; Add(a, b, c); Add(b, a, c); } Search(1, -1); std::cout \u003c\u003c f[1][m] \u003c\u003c std::endl; return 0; } ","date":"2021-10-18","objectID":"/tree-dp/:2:3","tags":["动态规划"],"title":"树形动态规划","uri":"/tree-dp/"},{"categories":["动态规划"],"content":"AcWing-323-战略游戏 一个点可以放或者不放，我们用$0$和$1$表示，那么$f_{i, j}$可以表示在以$i$为根的子树中放，且$i$的摆放情况是$j$的最少摆放个数。因此在以$u$为根的子树中（$u \\rightarrow v$）$f_{u, 0} = \\sum f_{v, 1}$，$f_{u, 1} = \\sum \\min(f_{v, 0}, f_{v, 1})$ #include \u003ciostream\u003e#include \u003ccstdio\u003e const int N = 1505; struct Edge { int to, next; } edges[N]; int n, head[N], total; int f[N][2]; bool isNotRoot[N]; void Add(int a, int b) { Edge \u0026e = edges[total]; e.to = b; e.next = head[a]; head[a] = total++; } void Search(int u) { f[u][0] = 0; f[u][1] = 1; for (int i = head[u]; i != -1; i = edges[i].next) { int v = edges[i].to; Search(v); f[u][0] += f[v][1]; f[u][1] += std::min(f[v][0], f[v][1]); } } int main() { while (scanf(\"%d\", \u0026n) != -1) { for (int i = 0; i \u003c N; i++) { head[i] = -1; isNotRoot[i] = false; } total = 0; for (int i = 1; i \u003c= n; i++) { int u, count; scanf(\"%d:(%d)\", \u0026u, \u0026count); for (int j = 1; j \u003c= count; j++) { int v; scanf(\"%d\", \u0026v); Add(u, v); isNotRoot[v] = true; } } int root = 0; while (isNotRoot[root]) root++; Search(root); printf(\"%d\\n\", std::min(f[root][1], f[root][0])); } return 0; } ","date":"2021-10-18","objectID":"/tree-dp/:2:4","tags":["动态规划"],"title":"树形动态规划","uri":"/tree-dp/"},{"categories":["动态规划"],"content":"LibreOJ-10157-皇宫看守 本题与上一题的唯一区别在于点上带了权值。但要注意，如果点上不带权值，最佳情况一定是有一个点看其它的点，这时两个数可以完美地表示一个点的状态；但本题由于权值的加入，最佳情况可能是两个点同时看中间的点，这时需要三个数才能满足状态的表示。 用$0$表示该点被父节点看到、$1$表示被子节点看到、$2$表示在该点放看守，$f_{i, j}$的定义和上题相同。可以得到$f_{u, 0} = \\sum \\min(f_{v, 1}, f_{v, 2})$，$f_{u, 2} = \\sum \\min(f_{v, 0}, f_{v, 1}, f_{v, 2})$和$f_{u, 1} = \\min(f_{v, 2} + f_{u, 0} - \\min(f_{v, 1}, f_{v, 2}))$。 #include \u003ciostream\u003e const int N = 1505, PosInf = 1e9; struct Edge { int to; int next; } edges[N]; int n, head[N], total; int f[N][3], cost[N]; bool isNotRoot[N]; void Add(int a, int b) { Edge \u0026e = edges[total]; e.to = b; e.next = head[a]; head[a] = total++; } void Search(int u) { f[u][2] = cost[u]; for (int i = head[u]; i != -1; i = edges[i].next) { int v = edges[i].to; Search(v); f[u][0] += std::min(f[v][1], f[v][2]); f[u][2] += std::min(std::min(f[v][0], f[v][1]), f[v][2]); } f[u][1] = PosInf; for (int i = head[u]; i != -1; i = edges[i].next) { int v = edges[i].to; f[u][1] = std::min(f[u][1], f[v][2] + f[u][0] - std::min(f[v][1], f[v][2])); } } int main() { for (int i = 0; i \u003c N; i++) head[i] = -1; std::cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { int u, w, count; std::cin \u003e\u003e u \u003e\u003e w \u003e\u003e count; cost[u] = w; for (int j = 1; j \u003c= count; j++) { int v; std::cin \u003e\u003e v; Add(u, v); isNotRoot[v] = true; } } int root = 1; while (isNotRoot[root]) root++; Search(root); std::cout \u003c\u003c std::min(f[root][1], f[root][2]) \u003c\u003c std::endl; return 0; } ","date":"2021-10-18","objectID":"/tree-dp/:2:5","tags":["动态规划"],"title":"树形动态规划","uri":"/tree-dp/"},{"categories":["动态规划"],"content":"问题简介 此类问题一般是求在一个特定范围内满足某种特殊性质的数的数量，也有求其它信息的类型。数位型动态规划做法基本类似，大多是预处理-按位枚举范围中的数-计数。 ","date":"2021-10-18","objectID":"/dp-on-numbers/:1:0","tags":["动态规划"],"title":"数位型动态规划","uri":"/dp-on-numbers/"},{"categories":["动态规划"],"content":"技巧 区间转换$[m, n] \\Rightarrow f_n - f_{m - 1}$ 按位枚举数时先考虑该位小于最高位，再考虑相等的情况（就像一棵二叉树）。 对于技巧2，枚举时的基本模板如下（不能处理去除前导0的情况） int Dp(int n) { if (n == 0) return 0; // 视具体情况而定 std::vector\u003cint\u003e nums; while (n \u003e 0) { nums.push_back(n % 10); // 模的数视具体情况而定 n /= 10; // 同上 } int res = 0, last = 0; // 枚举相等的情况时，可能需要记录上一个数来判断满足的性质 for (int i = nums.size() - 1; i \u003e= 0; i--) { int x = nums[i]; for (int j = 0; j \u003c x; j++) { if (...) // 满足条件，可能有多级 { res += f[...][...]; // 加上预处理的数 } } } } ","date":"2021-10-18","objectID":"/dp-on-numbers/:2:0","tags":["动态规划"],"title":"数位型动态规划","uri":"/dp-on-numbers/"},{"categories":["动态规划"],"content":"例题 ","date":"2021-10-18","objectID":"/dp-on-numbers/:3:0","tags":["动态规划"],"title":"数位型动态规划","uri":"/dp-on-numbers/"},{"categories":["动态规划"],"content":"LibreOJ-10163-Amount of Degrees 如果把这个数表示成B进制，问题就转化成了这个数的B进制下是否有K个1，而$i$位数中有$j$个1的数的数量正好是$i \\choose j$。 首先要确定的是，本题的方案数仅仅和整个数中的1有关，因此我们不用循环，只需要判断等于0、等于1和大于1。 要求$0$到$n$中满足条件的数的个数$res$，先预处理出$i \\choose j$，然后按位枚举$n$，枚举时记录$n$中1的个数$count$。如果这一位数是0，就到下一位去处理；如果这一位数是1，先让$res$加上预处理的数，再让$count$加一；如果这一位大于1，这一位后面的满足条件的数的个数就可以直接用预处理找到；最后由于$n$本身没有记录，如果满足条件，就让$res$加一。 #include \u003ciostream\u003e#include \u003cvector\u003e const int N = 33, K = 23; int x, y, k, b; int f[N][K]; void Init() { for (int i = 0; i \u003c N; i++) for (int j = 0; j \u003c= i; j++) { if (j == 0) f[i][j] = 1; else f[i][j] = f[i - 1][j] + f[i - 1][j - 1]; } } int Dp(int n) { if (n == 0) return 0; std::vector\u003cint\u003e nums; while (n \u003e 0) { nums.push_back(n % b); n /= b; } int res = 0, count = 0; for (int i = nums.size() - 1; i \u003e= 0; i--) { int x = nums[i]; if (x \u003e 0) { res += f[i][k - count]; if (x \u003e 1) { if (k - count - 1 \u003e= 0) res += f[i][k - count - 1]; break; } else { count++; if (count \u003e k) break; } } if (i == 0 \u0026\u0026 count == k) res++; } return res; } int main() { std::cin \u003e\u003e x \u003e\u003e y \u003e\u003e k \u003e\u003e b; Init(); std::cout \u003c\u003c Dp(y) - Dp(x - 1) \u003c\u003c std::endl; return 0; } ","date":"2021-10-18","objectID":"/dp-on-numbers/:3:1","tags":["动态规划"],"title":"数位型动态规划","uri":"/dp-on-numbers/"},{"categories":["动态规划"],"content":"LibreOJ-10164-数字游戏 预处理：用$f_{i, j}$表示有$i$位，且第一位是$j$的不降数的个数。$f_{i, j} = \\sum f_{i - 1, k} (j \\ge k)$。 求$1$到$n$满足条件的数的数量时，枚举每一位$x$并记录上一位$last$，先找到数$j$使$last \\le j \u003c x$并加上预处理的答案，然后考虑$j = x$的情况（进入下一位）。但要注意，如果$n$本身再某一位不满足不降数了，就不必再进行枚举。 #include \u003ciostream\u003e#include \u003cvector\u003e const int N = 15; int f[N][10]; void Init() { for (int i = 0; i \u003c= 9; i++) f[1][i] = 1; for (int i = 2; i \u003c N; i++) for (int j = 0; j \u003c= 9; j++) for (int k = j; k \u003c= 9; k++) f[i][j] += f[i - 1][k]; } int Dp(int n) { if (n == 0) return 1; std::vector\u003cint\u003e nums; while (n \u003e 0) { nums.push_back(n % 10); n /= 10; } int res = 0, last = 0; for (int i = nums.size() - 1; i \u003e= 0; i--) { int x = nums[i]; for (int j = last; j \u003c x; j++) res += f[i + 1][j]; if (x \u003c last) break; last = x; if (i == 0) res++; } return res; } int main() { Init(); int l, r; while (std::cin \u003e\u003e l \u003e\u003e r) std::cout \u003c\u003c Dp(r) - Dp(l - 1) \u003c\u003c std::endl; return 0; } ","date":"2021-10-18","objectID":"/dp-on-numbers/:3:2","tags":["动态规划"],"title":"数位型动态规划","uri":"/dp-on-numbers/"},{"categories":["动态规划"],"content":"洛谷-P2657-[SCOI2009] Windy数 方法类似，先预处理，再按位枚举。 但本题需要注意的是：不包含前导0。这要求我们判断包含前导0的情况并进行特殊处理： 在枚举过程中，第一位数不能为0； 枚举结束后，重新考虑有前导0的情况。 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003ccmath\u003e const int N = 15; int f[N][10]; void Init() { for (int i = 0; i \u003c= 9; i++) f[1][i] = 1; for (int i = 2; i \u003c N; i++) for (int j = 0; j \u003c= 9; j++) for (int k = 0; k \u003c= 9; k++) if (abs(j - k) \u003e= 2) f[i][j] += f[i - 1][k]; } int Dp(int n) { if (n == 0) return 0; std::vector\u003cint\u003e nums; while (n \u003e 0) { nums.push_back(n % 10); n /= 10; } int res = 0, last = -2; for (int i = nums.size() - 1; i \u003e= 0; i--) { int x = nums[i]; for (int j = (i == nums.size() - 1); j \u003c x; j++) if (abs(j - last) \u003e= 2) res += f[i + 1][j]; if (abs(x - last) \u003c 2) break; last = x; if (i == 0) res++; } // 有前导0 for (int i = 1; i \u003c nums.size(); i++) for (int j = 1; j \u003c= 9; j++) res += f[i][j]; return res; } int main() { Init(); int l, r; std::cin \u003e\u003e l \u003e\u003e r; std::cout \u003c\u003c Dp(r) - Dp(l - 1) \u003c\u003c std::endl; return 0; } ","date":"2021-10-18","objectID":"/dp-on-numbers/:3:3","tags":["动态规划"],"title":"数位型动态规划","uri":"/dp-on-numbers/"},{"categories":["动态规划"],"content":"LibreOJ-10166-数字游戏 #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e const int N = 13, M = 110; int MOD; int f[N][10][M]; int PosMod(int n, int p) { return (n % p + p) % p; } void Init() { memset(f, 0, sizeof(f)); for (int i = 0; i \u003c= 9; i++) f[1][i][PosMod(i, MOD)]++; for (int i = 2; i \u003c N; i++) for (int j = 0; j \u003c= 9; j++) for (int k = 0; k \u003c MOD; k++) for (int x = 0; x \u003c= 9; x++) f[i][j][k] += f[i - 1][x][PosMod(k - j, MOD)]; } int Dp(int n) { if (n == 0) return 1; std::vector\u003cint\u003e nums; while (n \u003e 0) { nums.push_back(n % 10); n /= 10; } int res = 0, last = 0; for (int i = nums.size() - 1; i \u003e= 0; i--) { int x = nums[i]; for (int j = 0; j \u003c x; j++) res += f[i + 1][j][PosMod(-last, MOD)]; last += x; if (i == 0 \u0026\u0026 last % MOD == 0) res++; } return res; } int main() { int l, r; while (std::cin \u003e\u003e l \u003e\u003e r \u003e\u003e MOD) { Init(); std::cout \u003c\u003c Dp(r) - Dp(l - 1) \u003c\u003c std::endl; } return 0; } ","date":"2021-10-18","objectID":"/dp-on-numbers/:3:4","tags":["动态规划"],"title":"数位型动态规划","uri":"/dp-on-numbers/"},{"categories":["动态规划"],"content":"LibreOJ-10167-不要62 #include \u003ciostream\u003e#include \u003cvector\u003e const int N = 7 + 2; int f[N][10]; void Init() { for (int i = 0; i \u003c= 9; i++) if (i != 4) f[1][i] = 1; for (int i = 2; i \u003c N; i++) for (int j = 0; j \u003c= 9; j++) if (j != 4) for (int k = 0; k \u003c= 9; k++) if (k != 4 \u0026\u0026 !(j == 6 \u0026\u0026 k == 2)) f[i][j] += f[i - 1][k]; } int Dp(int n) { if (n == 0) return 1; std::vector\u003cint\u003e nums; while (n \u003e 0) { nums.push_back(n % 10); n /= 10; } int res = 0, last = 0; for (int i = nums.size() - 1; i \u003e= 0; i--) { int x = nums[i]; for (int j = 0; j \u003c x; j++) if (j != 4 \u0026\u0026 !(last == 6 \u0026\u0026 j == 2)) res += f[i + 1][j]; if (x == 4 || (last == 6 \u0026\u0026 x == 2)) break; last = x; if (i == 0) res++; } return res; } int main() { Init(); int l, r; while (true) { std::cin \u003e\u003e l \u003e\u003e r; if (l == 0 \u0026\u0026 r == 0) return 0; std::cout \u003c\u003c Dp(r) - Dp(l - 1) \u003c\u003c std::endl; } return 0; } ","date":"2021-10-18","objectID":"/dp-on-numbers/:3:5","tags":["动态规划"],"title":"数位型动态规划","uri":"/dp-on-numbers/"},{"categories":["动态规划"],"content":"LibreOJ-10168-恨7不成妻 本题的难点在于要求所有数的平方和。这需要我们记录数的个数、和以及平方和。 #include \u003ciostream\u003e#include \u003cvector\u003e const int N = 18 + 2, MOD = 1e9 + 7; struct Pack { int count, sum, pow; } f[N][10][7][7]; int t7[N], tMod[N]; int PosMod(long long n, int p) { return (n % p + p) % p; } void Init() { t7[0] = tMod[0] = 1; for (int i = 1; i \u003c N; i++) { t7[i] = t7[i - 1] * 10 % 7; tMod[i] = (long long)tMod[i - 1] * 10 % MOD; } for (int i = 0; i \u003c= 9; i++) { if (i == 7) continue; Pack \u0026v = f[1][i][i % 7][i % 7]; v.count++; v.sum += i; v.pow += i * i; } for (int i = 2; i \u003c N; i++) for (int j = 0; j \u003c= 9; j++) { if (j == 7) continue; for (int a = 0; a \u003c 7; a++) for (int b = 0; b \u003c 7; b++) for (int k = 0; k \u003c= 9; k++) { if (k == 7) continue; Pack \u0026p = f[i][j][a][b]; Pack \u0026l = f[i - 1][k][PosMod(a - j * t7[i - 1], 7)][PosMod(b - j, 7)]; p.count = (p.count + l.count) % MOD; p.sum = (p.sum + (long long)j * tMod[i - 1] % MOD * l.count % MOD + l.sum) % MOD; p.pow = (p.pow + (long long)j * j * tMod[i - 1] % MOD * tMod[i - 1] % MOD * l.count % MOD + (long long)2 * j * tMod[i - 1] % MOD * l.sum % MOD + l.pow) % MOD; } } } Pack Match(int i, int j, int notA, int notB) { int count = 0, sum = 0, pow = 0; for (int a = 0; a \u003c 7; a++) for (int b = 0; b \u003c 7; b++) { if (a == notA || b == notB) continue; Pack \u0026v = f[i][j][a][b]; count = (count + v.count) % MOD; sum = (sum + v.sum) % MOD; pow = (pow + v.pow) % MOD; } return {count, sum, pow}; } long long Dp(long long n) { if (n == 0) return 0; long long backup = n % MOD; std::vector\u003cint\u003e nums; while (n \u003e 0) { nums.push_back(n % 10); n /= 10; } long long res = 0; long long lastA = 0, lastB = 0; for (int i = nums.size() - 1; i \u003e= 0; i--) { int x = nums[i]; for (int j = 0; j \u003c x; j++) { if (j == 7) continue; int notA = PosMod(-lastA % 7 * t7[i + 1], 7); int notB = PosMod(-lastB, 7); Pack v = Match(i + 1, j, notA, notB); res = (res + (lastA % MOD) * (lastA % MOD) % MOD * tMod[i + 1] % MOD * tMod[i + 1] % MOD * v.count % MOD + 2 * (lastA % MOD) % MOD * tMod[i + 1] % MOD * v.sum % MOD + v.pow) % MOD; } if (x == 7) break; lastA = lastA * 10 + x; lastB += x; if (i == 0 \u0026\u0026 lastA % 7 != 0 \u0026\u0026 lastB % 7 != 0) res = (res + backup * backup) % MOD; } return res; } int main() { Init(); int T; std::cin \u003e\u003e T; for (int test = 1; test \u003c= T; test++) { long long l, r; std::cin \u003e\u003e l \u003e\u003e r; std::cout \u003c\u003c PosMod(Dp(r) - Dp(l - 1), MOD) \u003c\u003c std::endl; } return 0; } ","date":"2021-10-18","objectID":"/dp-on-numbers/:3:6","tags":["动态规划"],"title":"数位型动态规划","uri":"/dp-on-numbers/"},{"categories":["动态规划"],"content":"分类 基本有两种： 棋盘式的动态规划（基于联通性） 集合式的动态规划 ","date":"2021-08-23","objectID":"/state-compressed-dp/:1:0","tags":["动态规划"],"title":"状态压缩的动态规划","uri":"/state-compressed-dp/"},{"categories":["动态规划"],"content":"状态压缩 利用某些手段（以二进制压缩为主）将复杂的状态处理后存储。 ","date":"2021-08-23","objectID":"/state-compressed-dp/:2:0","tags":["动态规划"],"title":"状态压缩的动态规划","uri":"/state-compressed-dp/"},{"categories":["动态规划"],"content":"分类 ","date":"2021-08-23","objectID":"/state-compressed-dp/:3:0","tags":["动态规划"],"title":"状态压缩的动态规划","uri":"/state-compressed-dp/"},{"categories":["动态规划"],"content":"棋盘式的动态规划 给你一个棋盘，要在棋盘上摆放一些东西，但又有一些限制，求方案数/最多摆放数量。这类问题一般将每一行（自上而下递推）或每一列（自左而右递推）的摆放情况压缩成一个二进制数，每一位对应一个位置的摆放情况，然后根据题目限制设计递推式。 ","date":"2021-08-23","objectID":"/state-compressed-dp/:3:1","tags":["动态规划"],"title":"状态压缩的动态规划","uri":"/state-compressed-dp/"},{"categories":["动态规划"],"content":"集合式的动态规划 其实和上面类似，也是将一组数二进制压缩成一个数，只不过这一组数不表示棋盘上的一行或一列。 ","date":"2021-08-23","objectID":"/state-compressed-dp/:3:2","tags":["动态规划"],"title":"状态压缩的动态规划","uri":"/state-compressed-dp/"},{"categories":["动态规划"],"content":"例题 LOJ-10170-国王 / LOJ-2153-「SCOI2005」互不侵犯 本题属于棋盘式的动态规划。 可以发现，每一行的摆放情况只与上一行有关。并且每一行的摆放情况可以用一个二进制数表示。因此，我们用$f_{i, k, state}$表示放完$i$行，至多放$k$个，且第$i$行的摆放情况是$state$的最多摆放数量。 若用$s_i$、$s_j$分别表示相邻的两行，那么由于国王不能上下相邻，所以$s_i \\land s_j$必须为$0$，又因为国王间至少隔2格，那么必须满足$s_i$、$s_j$、$s_i \\lor s_j$没有相邻的两位都是$1$。 排除了错误的摆放情况，我们可以用一个std::vector\u003cint\u003e存储所有可能的情况，再用一个std::vector\u003cint\u003e的数组表示状态间的可能的转移。 为了减少计算，我们还可以用一个数组count[state]表示特定状态的国王个数。 **小技巧：最后不必枚举最后一行的状态再相加，可以递推到原有行数的下一行，用$f_{n + 1, m, 0}$表示答案。** #include \u003ciostream\u003e#include \u003cvector\u003e const int N = 12, M = 1024, K = 105; int n, m, count[M]; long long f[N][K][M]; std::vector\u003cint\u003e s; std::vector\u003cint\u003e to[M]; bool Check(int state) { for (int i = 0; i \u003c n; i++) if (((state \u003e\u003e i) \u0026 1) \u0026\u0026 ((state \u003e\u003e (i + 1)) \u0026 1)) return false; return true; } int CountKing(int state) { int res = 0; for (int i = 0; i \u003c n; i++) if ((state \u003e\u003e i) \u0026 1) res++; return res; } int main() { std::cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c (1 \u003c\u003c n); i++) if (Check(i)) { s.push_back(i); count[i] = CountKing(i); } for (int i = 0; i \u003c s.size(); i++) for (int j = 0; j \u003c s.size(); j++) { int prev = s[i], next = s[j]; if (((prev \u0026 next) == 0) \u0026\u0026 Check(prev | next)) to[i].push_back(j); } f[0][0][0] = 1; for (int i = 1; i \u003c= n + 1; i++) for (int j = 0; j \u003c= m; j++) for (int prev = 0; prev \u003c s.size(); prev++) for (int next : to[prev]) { int c = count[s[prev]]; if (j \u003e= c) f[i][j][next] += f[i - 1][j - c][prev]; } std::cout \u003c\u003c f[n + 1][m][0] \u003c\u003c std::endl; return 0; } AcWing-327-玉米田 与上一题类似，但要注意有的土地不能种。要排除那些种植情况，我们可以用一个数组g[line]表示该行不能种的情况（将不能种的位定为$1$），如果一个种植情况$state$和g[line]有公共的位置（即两者相与不为$0$），这个情况就要排除。 #include \u003ciostream\u003e#include \u003cvector\u003e const int N = 14, M = 4096, MOD = 1e8; int n, m; int g[N]; std::vector\u003cint\u003e s; std::vector\u003cint\u003e to[M]; int f[N][M]; bool Check(int state) { for (int i = 0; i \u003c m; i++) if (((state \u003e\u003e i) \u0026 1) \u0026\u0026 ((state \u003e\u003e (i + 1)) \u0026 1)) return false; return true; } int main() { std::cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) for (int j = 0; j \u003c m; j++) { bool t; std::cin \u003e\u003e t; g[i] += (!t) \u003c\u003c j; } for (int i = 0; i \u003c (1 \u003c\u003c m); i++) if (Check(i)) s.push_back(i); for (int i = 0; i \u003c s.size(); i++) for (int j = 0; j \u003c s.size(); j++) { int prev = s[i], next = s[j]; if ((prev \u0026 next) == 0) to[i].push_back(j); } f[0][0] = 1; for (int i = 1; i \u003c= n + 1; i++) for (int prev = 0; prev \u003c s.size(); prev++) for (int next : to[prev]) { if (g[i] \u0026 s[next]) continue; f[i][next] = (f[i][next] + f[i - 1][prev]) % MOD; } std::cout \u003c\u003c f[n + 1][0] \u003c\u003c std::endl; return 0; } 洛谷-P2704-[NOI2001] 炮兵阵地 与上一题类似，本题有的地方不能放炮兵部队。但本题与前面的区别在于，影响的范围多了一格，因此第$i$行的摆放情况与第$i - 1$行、第$i - 2$行有关。用$f_{i, s1, s2}$表示放完$i$行，第$i$行状态是$s1$、第$i - 1$行状态是$s2$。 为压缩空间，这里用了滚动数组。 #include \u003ciostream\u003e#include \u003cvector\u003e const int N = 105, M = 11, K = 1024; int n, m; int g[N], count[K]; std::vector\u003cint\u003e s; int f[2][K][K]; bool Check(int state) { for (int i = 0; i \u003c m; i++) if (((state \u003e\u003e i) \u0026 1) \u0026\u0026 (((state \u003e\u003e (i + 1)) \u0026 1) || ((state \u003e\u003e (i + 2)) \u0026 1))) return false; return true; } int GetCount(int state) { int res = 0; for (int i = 0; i \u003c m; i++) if ((state \u003e\u003e i) \u0026 1) res++; return res; } int main() { std::cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) for (int j = 0; j \u003c m; j++) { char c; std::cin \u003e\u003e c; if (c == 'H') g[i] += 1 \u003c\u003c j; } for (int i = 0; i \u003c (1 \u003c\u003c m); i++) if (Check(i)) { s.push_back(i); count[i] = GetCount(i); } for (int i = 1; i \u003c= n + 2; i++) for (int a = 0; a \u003c s.size(); a++) // i for (int b = 0; b \u003c s.size(); b++) // i - 1 for (int c = 0; c \u003c s.size(); c++) // i - 2 { int p = s[a], q = s[b], r = s[c]; if ((p \u0026 q) | (q \u0026 r) | (p \u0026 r)) continue; if ((g[i] \u0026 p) | (g[i - 1] \u0026 q)) continue; f[i \u0026 1][a][b] = std::max(f[i \u0026 1][a][b], f[(i - 1) \u0026 1][b][c] + count[p]); } std::cout \u003c\u003c f[(n + 2) \u0026 1][0][0] \u003c\u003c std::endl; return 0; } 洛谷-P831-[NOIP2016 提高组] 愤怒的小鸟 本题属于集合式的动态规划。 可以把一条抛物线覆盖的猪按猪的编号二进制压缩成一个数，用$f_{state}$表示达到这一状态的最少抛物线数量。由于本题中的抛物线一定过原点，所以只要找到另外两个点就可以确定一条抛物线，我们用$path_{i, j}$表示有一条抛物线经过$i$、$j$的覆盖情况。 处理完$path_{i, j}$后，我们枚举状态$state$并扫描它，找到第一个猪没有被覆盖的位置并标记，并用与它构成的$path$来更新$state$。转移方程如下： $$ f_{state \\","date":"2021-08-23","objectID":"/state-compressed-dp/:4:0","tags":["动态规划"],"title":"状态压缩的动态规划","uri":"/state-compressed-dp/"},{"categories":["数据结构"],"content":"滑动窗口问题 洛谷-P1886-滑动窗口/【模板】单调队列 有一个长为$n$的序列$a$，以及一个大小为$k$的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。 如果每次都遍历整个窗口，时间复杂度为$O(nk)$，相当高。但其中我们进行了很多无效的比较，比如已知一个数在窗口中小于另一个，进入下一个窗口时还在进行比较。 为了解决这个问题，我们引入一种数据结构————单调队列。 ","date":"2021-08-11","objectID":"/monotonous-queue/:1:0","tags":["数据结构"],"title":"单调队列","uri":"/monotonous-queue/"},{"categories":["数据结构"],"content":"单调队列的原理和性质 既然叫“单调”队列，单调队列中的元素体现了以下的单调性： 元素排列具有单调性（增/减/其他） 取出元素的位置组成的序列具有单调性（不会倒回去取） 注意：单调队列只能同时体现一种单调性。 如何实现上面提到的单调性？单调队列采用了如下的方法： 如果新加入的元素满足单调性，从尾部入队 如果新加入的元素比队列中所有元素都大/小/其他，清空队列，把它请进来 （满足滑动窗口问题的条件）如果元素过期（在窗口外），从头部出队 由于严格保证了单调性，最值可以直接在队头取。 示例代码： #include \u003ciostream\u003e#include \u003cqueue\u003e const int N = 1e6 + 5; int n, k, a[N]; void GetMin() { std::deque\u003cint\u003e q; for (int i = 1; i \u003c= n; i++) { if (!q.empty() \u0026\u0026 i - k \u003e= q.front()) q.pop_front(); while (!q.empty() \u0026\u0026 a[i] \u003c= a[q.back()]) q.pop_back(); q.push_back(i); if (i \u003e= k) std::cout \u003c\u003c a[q.front()] \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; } void GetMax() { std::deque\u003cint\u003e q; for (int i = 1; i \u003c= n; i++) { if (!q.empty() \u0026\u0026 i - k \u003e= q.front()) q.pop_front(); while (!q.empty() \u0026\u0026 a[i] \u003e= a[q.back()]) q.pop_back(); q.push_back(i); if (i \u003e= k) std::cout \u003c\u003c a[q.front()] \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; } int main() { std::cin \u003e\u003e n \u003e\u003e k; for (int i = 1; i \u003c= n; i++) std::cin \u003e\u003e a[i]; GetMin(); GetMax(); return 0; } ","date":"2021-08-11","objectID":"/monotonous-queue/:2:0","tags":["数据结构"],"title":"单调队列","uri":"/monotonous-queue/"},{"categories":["动态规划"],"content":"最长上升子序列（LIS）问题 给出一个由数字组成的序列，要求从中挑选尽量多的数，组成一个单调上升的子序列。 要解决这个问题，我们可以这样想： 如果现在有了一个最长上升子序列，我们要在后面加一个数。如果这个数比最长上升子序列的最后一个数大，我们可以将它加入其中；如果更小，那只能去找找稍微短一些的上升子序列，看看能不能加入；实在没有，那就保持现状。 这个思路很清晰，但由于添加的数是否在序列中未知，处理起来比较麻烦。此时我们要求以加入的数结尾，再递推就简单许多了，可以写出如下的转移方程： $$ f_i = \\max(1, (a_j \u003c a_i)(f_j + 1)) $$ 初始值为$0$，答案$\\max(f_i)$ 因此我们可以把代码写出来： #include \u003ciostream\u003e const int N = 1005; int n; int a[N], f[N]; int main() { std::cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { std::cin \u003e\u003e a[i]; } for (int i = 1; i \u003c= n; i++) { f[i] = 1; for (int j = 1; j \u003c i; j++) { if (a[j] \u003c a[i]) f[i] = std::max(f[i], f[j] + 1); } } int ans = 0; for (int i = 1; i \u003c= n; i++) ans = std::max(ans, f[i]); std::cout \u003c\u003c ans \u003c\u003c std::endl; return 0; } ","date":"2021-08-11","objectID":"/lis-and-lcs-problem/:1:0","tags":["动态规划"],"title":"LIS和LCS","uri":"/lis-and-lcs-problem/"},{"categories":["动态规划"],"content":"例题 AcWing-482-合唱队形 本题求最少同学出列，其实就是求最长上升后下降子序列，然后用总数减就是了。 求最长上升后下降子序列时，只需要分别求上升和下降，但一定要注意，要保证两次递推时，每次控制作为结尾的数要是“峰顶”，我之前图方便，想在一个循环里搞定，就出错了。 AC代码： #include \u003ciostream\u003e const int N = 1005; int n, h[N]; int up[N], down[N]; int main() { int n; std::cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) std::cin \u003e\u003e h[i]; for (int i = 1; i \u003c= n; i++) { up[i] = 1; for (int j = 1; j \u003c i; j++) if (h[i] \u003e h[j]) up[i] = std::max(up[i], up[j] + 1); } for (int i = n; i \u003e 0; i--) { down[i] = 1; for (int j = n; j \u003e i; j--) if (h[i] \u003e h[j]) down[i] = std::max(down[i], down[j] + 1); } int res = 0; for (int i = 1; i \u003c= n; i++) res = std::max(res, up[i] + down[i] - 1); std::cout \u003c\u003c n - res \u003c\u003c std::endl; return 0; } ","date":"2021-08-11","objectID":"/lis-and-lcs-problem/:1:1","tags":["动态规划"],"title":"LIS和LCS","uri":"/lis-and-lcs-problem/"},{"categories":["动态规划"],"content":"最长公共子序列（LCS）问题 给出两个由数字组成的序列，要求从中挑选尽量多的两个序列共有的数，组成子序列。 要考虑这个问题，我们可以顺着刚才的思路，用已知信息推出未知。 代码如下： #include \u003ciostream\u003e const int N = 1005; int n, m, d[N][N]; char a[N], b[N]; int main() { std::cin \u003e\u003e n \u003e\u003e m \u003e\u003e a + 1 \u003e\u003e b + 1; // getline(std::cin, a); // getline(std::cin, b); for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) { d[i][j] = std::max(d[i - 1][j], d[i][j - 1]); if (a[i] == b[j]) d[i][j] = std::max(d[i][j], d[i - 1][j - 1] + 1); } std::cout \u003c\u003c d[n][m] \u003c\u003c std::endl; return 0; } ","date":"2021-08-11","objectID":"/lis-and-lcs-problem/:2:0","tags":["动态规划"],"title":"LIS和LCS","uri":"/lis-and-lcs-problem/"},{"categories":["动态规划"],"content":"两个问题的联系 我们可以发现，两个问题中状态表示的关键都在“最后一个”，或者说“新加入的一个”，这样处理方便了对转移方向的判断。 ","date":"2021-08-11","objectID":"/lis-and-lcs-problem/:3:0","tags":["动态规划"],"title":"LIS和LCS","uri":"/lis-and-lcs-problem/"},{"categories":["动态规划"],"content":"例题 AcWing-274-最长公共上升子序列 #include \u003ciostream\u003e const int N = 3005; int n, a[N], b[N]; int f[N][N]; int main() { std::cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) std::cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i++) std::cin \u003e\u003e b[i]; for (int i = 1; i \u003c= n; i++) { int maxv = 0; for (int j = 1; j \u003c= n; j++) { f[i][j] = f[i - 1][j]; if (a[i] == b[j]) f[i][j] = std::max(f[i][j], maxv + 1); if (a[i] \u003e b[j]) maxv = std::max(maxv, f[i][j]); } } int res = 0; for (int i = 1; i \u003c= n; i++) res = std::max(res, f[n][i]); std::cout \u003c\u003c res \u003c\u003c std::endl; return 0; } ","date":"2021-08-11","objectID":"/lis-and-lcs-problem/:3:1","tags":["动态规划"],"title":"LIS和LCS","uri":"/lis-and-lcs-problem/"},{"categories":["动态规划"],"content":"石子合并问题 有若干个石子排成一行，每个石子有一定的质量，现在要将它们合并成一堆，每一次合并产生的价值是两堆石子的质量和（只能合并相邻的石子），求最大/最小价值。 以最小值为例，对于这个问题，如果我们用$f_{i, j}$表示从$i$到$j$的代价最小值，那么这一块区域可以被分割成两个小的区域，通过不断调整分割点，我们就可以找到$f_{i, j}$，转移方程如下： $$ f_{i, j} = \\min(f_{i, j}, f_{i, k} + f_{k + 1, j} + s[j] - s[i - 1]) (i \\le k \u003c j) $$ 初始值： $$ f_{i, i} = 0 $$ 时间复杂度$O(n ^ 3)$。 如果石子排成了一个环呢？ ","date":"2021-08-11","objectID":"/range-dp/:1:0","tags":["动态规划"],"title":"区间型动态规划","uri":"/range-dp/"},{"categories":["动态规划"],"content":"环形石子合并问题 一般来说，有下面几种转换方法： 把环变成链，枚举那个缺口，时间复杂度$O(n ^ 4)$； 考虑到变成环之后，问题转换为求$n$条链上的石子合并问题，那么可以把长度为$n$的链拆开，复制一次，变成长度为$2n$的链，用石子合并的方法求出$f_{i, j}$后，求出$\\min(f_{i, i + n - 1})$，时间复杂度$O(8n ^ 3)$； 显然第二种更好。 洛谷-P1880-[NOI1995] 石子合并 #include \u003ciostream\u003e const int N = 205, PosInf = 1e9; int n; int a[N], s[N], f[N][N], g[N][N]; int main() { for (int i = 0; i \u003c N; i++) for (int j = 0; j \u003c N; j++) { if (i == j) f[i][i] = g[i][i] = 0; else { f[i][j] = PosInf; g[i][j] = -PosInf; } } std::cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { std::cin \u003e\u003e a[i]; a[i + n] = a[i]; } for (int i = 1; i \u003c= n * 2; i++) s[i] = s[i - 1] + a[i]; for (int len = 1; len \u003c= n; len++) for (int l = 1; l + len - 1 \u003c= n * 2; l++) { int r = l + len - 1; for (int k = l; k \u003c r; k++) { f[l][r] = std::min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); g[l][r] = std::max(g[l][r], g[l][k] + g[k + 1][r] + s[r] - s[l - 1]); } } int wMin = PosInf, wMax = -PosInf; for (int l = 1; l \u003c= n; l++) { wMin = std::min(wMin, f[l][l + n - 1]); wMax = std::max(wMax, g[l][l + n - 1]); } std::cout \u003c\u003c wMin \u003c\u003c std::endl; std::cout \u003c\u003c wMax \u003c\u003c std::endl; return 0; } ","date":"2021-08-11","objectID":"/range-dp/:2:0","tags":["动态规划"],"title":"区间型动态规划","uri":"/range-dp/"},{"categories":["动态规划"],"content":"问题拓展 AcWing-320-能量项链 本题和前面的合并略有不同，待合并的两个区间不是由点构成，而是由点与点之间的空隙构成。因此区间长度至少是3，至多是$n + 1$，且断点$k$不能和左端点相等。 #include \u003ciostream\u003e const int N = 205, PosInf = 1e9; int n; int a[N], f[N][N]; int main() { std::cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { std::cin \u003e\u003e a[i]; a[i + n] = a[i]; } for (int len = 3; len \u003c= n + 1; len++) for (int l = 1; l + len - 1 \u003c= n * 2; l++) { int r = l + len - 1; for (int k = l + 1; k \u003c r; k++) f[l][r] = std::max(f[l][r], f[l][k] + f[k][r] + a[l] * a[k] * a[r]); } int wMax = -PosInf; for (int l = 1; l \u003c= n; l++) wMax = std::max(wMax, f[l][l + n]); std::cout \u003c\u003c wMax \u003c\u003c std::endl; return 0; } LibreOJ-10149-凸多边形的划分 可以将一个多边形的划分拆为三部分：左，中（三角形），右。最小价值即为这三者的价值和，于是可以发现转移方程和能量项链类似： $$ f_{i, j} = \\min(f_{i, j}, f_{i, k} + f{k, j} + w_i w_k w_j) $$ 注意，本题数据较大，需要做高精度。 #include \u003ciostream\u003e#include \u003ccstring\u003e const int N = 55, M = 35, PosInf = 1e9; int n, w[N]; long long f[N][N][M]; void Add(long long a[], long long b[]) { static long long c[M]; memset(c, 0, sizeof(c)); for (int i = 0, t = 0; i \u003c M; i++) { t += a[i] + b[i]; c[i] = t % 10; t /= 10; } memcpy(a, c, sizeof(c)); } void Mul(long long a[], long long b) { static long long c[M]; memset(c, 0, sizeof(c)); long long t = 0; for (int i = 0; i \u003c M; i++) { t += a[i] * b; c[i] = t % 10; t /= 10; } memcpy(a, c, sizeof(c)); } int Comp(long long a[], long long b[]) { for (int i = M - 1; i \u003e= 0; i--) if (a[i] \u003e b[i]) return 1; else if (a[i] \u003c b[i]) return -1; return 0; } int main() { std::cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) std::cin \u003e\u003e w[i]; long long temp[M]; for (int len = 3; len \u003c= n + 1; len++) for (int l = 1; l + len - 1 \u003c= n; l++) { int r = l + len - 1; f[l][r][M - 1] = 1; for (int k = l + 1; k \u003c r; k++) { memset(temp, 0, sizeof(temp)); temp[0] = w[l]; Mul(temp, w[k]); Mul(temp, w[r]); Add(temp, f[l][k]); Add(temp, f[k][r]); if (Comp(f[l][r], temp) \u003e 0) memcpy(f[l][r], temp, sizeof(temp)); } } int k = M - 1; while (k \u003e 0 \u0026\u0026 f[1][n][k] == 0) k--; for (int i = k; i \u003e= 0; i--) std::cout \u003c\u003c f[1][n][i]; std::cout \u003c\u003c std::endl; return 0; } AcWing-479-加分二叉树 这个题乍一看似乎和动态规划没有关系，但我们仔细分析“中序”，可以发现，正如区间中用点分割，中序遍历中，左右子树和根正好可以通过区间型动态规划的经典处理方式划分。因此用$f_{i, j}$表示中序遍历为输入数组的$i$到$j$位的二叉树中加分的最大值，但由于要输出具体方案，还要用$g_{i, j}$表示中序遍历为输入数组的$i$到$j$位的二叉树的根的序号。 #include \u003ciostream\u003e const int N = 35; int n, w[N]; int f[N][N], g[N][N]; void Print(int l, int r) { if (l \u003e r) return; int root = g[l][r]; std::cout \u003c\u003c root \u003c\u003c \" \"; Print(l, root - 1); Print(root + 1, r); } int main() { std::cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) std::cin \u003e\u003e w[i]; for (int len = 1; len \u003c= n; len++) for (int l = 1; l + len - 1 \u003c= n; l++) { int r = l + len - 1; if (len == 1) { f[l][r] = w[l]; g[l][r] = l; } else { for (int k = l; k \u003c= r; k++) { int subl = (k == l) ? 1 : f[l][k - 1]; int subr = (k == r) ? 1 : f[k + 1][r]; int score = subl * subr + w[k]; if (f[l][r] \u003c score) { f[l][r] = score; g[l][r] = k; } } } } std::cout \u003c\u003c f[1][n] \u003c\u003c std::endl; Print(1, n); return 0; } AcWing-321-棋盘分割 本题的划分分为横向和纵向，同时区间也由一维扩展到了二维，因此实现时可以用记忆化搜索的方式减少代码量。用$f_{x1, y1, x2, y2, k}$表示$(x1, y1)$到$(x2, y2)$这个二维区间分割$k$次的最小均方差，那么这个区间可以横向或纵向划分，且可以任意选取划分后的两个子区间，按照这个逻辑，可以写出下面的代码： #include \u003ciostream\u003e#include \u003ciomanip\u003e#include \u003ccmath\u003e#include \u003ccstring\u003e const int m = 8, M = 9, N = 20, PosInf = 1e9; int n, s[M][M]; double f[M][M][M][M][N]; double average; double Calc(int x1, int y1, int x2, int y2) { double sum = s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]; return (sum - average) * (sum - average) / n; } double Search(int x1, int y1, int x2, int y2, int k) { double \u0026v = f[x1][y1][x2][y2][k]; if (v \u003e= 0) return v; if (k == 1) return v = Calc(x1, y1, x2, y2); v = PosInf; for (int i = x1; i \u003c x2; i++) { v = std::min(v, Search(x1, y1, i, y2, k - 1) + Calc(i + 1, y1, x2, y2)); v = std::min(v, Search(i + 1, y1, x2, y2, k - 1) + Calc(x1, y1, i, y2)); } for (int i = y1; i \u003c y2; i++) { v = std::min(v, Search(x1, y1, x2, i, k - 1) + Calc(x1, i + 1, x2, y2)); v = std::min(v, Search(x1, i + 1, x2, y2, k - 1) + Calc(x1, y1, x2, i)); } return v; } int main() { std::c","date":"2021-08-11","objectID":"/range-dp/:2:1","tags":["动态规划"],"title":"区间型动态规划","uri":"/range-dp/"},{"categories":["动态规划"],"content":"区间型动态规划的两种实现方式 ","date":"2021-08-11","objectID":"/range-dp/:3:0","tags":["动态规划"],"title":"区间型动态规划","uri":"/range-dp/"},{"categories":["动态规划"],"content":"迭代式（推荐） for (int len = 1; len \u003c= n; len++) for (int l = 1; l + len - 1 \u003c= n; l++) { r = l + len - 1; for (int k = l; k \u003c r; k++) // do something } ","date":"2021-08-11","objectID":"/range-dp/:3:1","tags":["动态规划"],"title":"区间型动态规划","uri":"/range-dp/"},{"categories":["动态规划"],"content":"记忆化搜索式（适合状态定义较为复杂的情况） 如果状态定义中数组维数太多，需要些很多重循环，这时可以用记忆化搜索的形式来写。 ","date":"2021-08-11","objectID":"/range-dp/:3:2","tags":["动态规划"],"title":"区间型动态规划","uri":"/range-dp/"},{"categories":["动态规划"],"content":"问题描述 一个由数字构成的三角形，自上而下选出若干个数（不能向上走），这些数的和最大/最小是？ 在一个矩形地图中行走，只能向右或向下，每到一个点的花费是一个特定的数，求最小花费？ 以上是数字三角形模型的两种典型形式，它们的共同特征在于严格规定了递推的方向，将问题简化。此类问题可以求最值、方案数。 ","date":"2021-08-11","objectID":"/number-triangle/:1:0","tags":["动态规划"],"title":"数字三角形","uri":"/number-triangle/"},{"categories":["动态规划"],"content":"核心转移 $$ f_{i, j} = \\max(f_{i - 1, j}, f_{i, j - 1} + w_{i, j}) $$ 我们可以考虑用$f_{i, j}$表示从$(1, 1)$走到$(i, j)$的路径的集合，由于只能向右或向下走，很明显$(i, j)$要么从$(i - 1, j)$走，要么从$(i, j - 1)$，这样就可以一路递推到答案。 根据定义，$f$的初始值为$\\pm \\infty$，$f_{1, 1}$为$1$或$w_{1, 1}$,$f_{n, m}$是最终答案。 ","date":"2021-08-11","objectID":"/number-triangle/:2:0","tags":["动态规划"],"title":"数字三角形","uri":"/number-triangle/"},{"categories":["动态规划"],"content":"几个例题 CH0206-2728-摘花生 CH0206-7625-三角形最佳路径问题 CH0206-8786-方格取数 ","date":"2021-08-11","objectID":"/number-triangle/:3:0","tags":["动态规划"],"title":"数字三角形","uri":"/number-triangle/"},{"categories":["动态规划"],"content":"状态机是数学模型 有限状态自动机（以下简称状态机），是用来抽象事物运行规则的数学模型，我们可以把状态机看成一个图，结点代表各个状态，边代表状态间的转换。 我们来看一个最简单的例子：自动门。自动门只有开和关两种状态，关可以转换到开，开可以转换到关。 ","date":"2021-08-11","objectID":"/dfa/:1:0","tags":["动态规划"],"title":"状态机","uri":"/dfa/"},{"categories":["动态规划"],"content":"状态机模型在动态规划中的运用 状态间的转换可以看作状态转移，因此，使用状态机模型将问题分析清楚后，可以自然地写出转移方程。 例题：AcWing-1057-股票买卖 IV 用$f_{i, j, 0}$表示在第$i$天，交易次数为$j$，不持有股票时的最大收益，$f_{i, j, 1}$表示持有股票的最大收益。 那么我们可以把这两种状态构建成状态机模型： 不持有股票，可以继续不持有，也可以买入 持有股票，可以继续持有，也可以卖出 因此可以写出转移方程： $$ f_{i, j, 0} = \\max(f_{i - 1, j, 0}, f_{i - 1, j, 1} + w_i) \\ f_{i, j, 1} = \\max(f_{i - 1, j, 1}, f_{i - 1, j - 1, 0} - w_i) $$ #include \u003ciostream\u003e#include \u003ccstring\u003e const int N = 1e5 + 5, M = 105; int n, m; int w[N]; int f[N][M][2]; int main() { std::cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) std::cin \u003e\u003ew[i]; memset(f, -0x3f, sizeof(f)); for (int i = 0; i \u003c= n; i++) f[i][0][0] = 0; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) { f[i][j][0] = std::max(f[i - 1][j][0], f[i - 1][j][1] + w[i]); f[i][j][1] = std::max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]); } int res = 0; for (int i = 0; i \u003c= m; i++) res = std::max(res, f[n][i][0]); std::cout \u003c\u003c res \u003c\u003c std::endl; return 0; } ","date":"2021-08-11","objectID":"/dfa/:2:0","tags":["动态规划"],"title":"状态机","uri":"/dfa/"},{"categories":["动态规划"],"content":"01背包 现在有一个固定容量的背包，和若干体积一定、价值一定的物品，要将一些物品放入背包中，并获得最大的价值。 如果我们已经有了一个装有最大价值物品的背包，要对它进行扩容，并装入体积为$v_i$，价值为$w_i$的物品，此时最大价值就是原来的价值加上新增物品的价值。如果用$f_{i, j}$表示选到第$i$个物品，总体积为$j$，依照这个思路写出的转移方程如下： $$ f_{i, j} = f_{i - 1, j} \\ f_{i, j} = \\max(f_{i - 1, j - v_i} + w_i) $$ ","date":"2021-08-11","objectID":"/pack-dp/:1:0","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"恰好和不超过 其实认真想想，不管$j$是指“恰好”还是“不超过”，转移方程是不变的。但要注意在初始化的时候，“恰好”型需要将$f_0$外的$f$数组初始化为$-\\infty$ ","date":"2021-08-11","objectID":"/pack-dp/:1:1","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"空间优化 可以发现，$f_{i, j}$由$f_{i - 1, j}$和$f_{i - 1, j - v_i} + w_i$递推而来，只跟上一个状态有关，因此可以将$O(NM)$的空间复杂度优化至$O(M)$，只需要控制倒序循环（先更新大的，保证不会让新的去更新新的）即可。 ","date":"2021-08-11","objectID":"/pack-dp/:1:2","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"时间优化 因为该问题不受后面信息的影响，可以在读入时直接开始递推。 模板代码如下： #include \u003ciostream\u003e const int N = 1005, V = 1005; int n, v; int itemSpace[N], itemWeight[N]; int SinglePack() { int d[N][V]; for (int i = 0; i \u003c N; i++) for (int j = 0; j \u003c V; j++) d[i][j] = 0; // subsets of d[i, j]: a. has i; b. without i (d[i - 1, j]). for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= v; j++) { d[i][j] = d[i - 1][j]; if (itemSpace[i] \u003c= j) d[i][j] = std::max(d[i][j], d[i - 1][j - itemSpace[i]] + itemWeight[i]); } } return d[n][v]; } int SinglePackOptimized() { int d[V]; for (int i = 0; i \u003c V; i++) d[i] = 0; // subsets of d[i, j]: a. has i; b. without i (d[i - 1, j]). for (int i = 1; i \u003c= n; i++) { for (int j = v; j \u003e= itemSpace[i]; j--) { d[j] = std::max(d[j], d[j - itemSpace[i]] + itemWeight[i]); } } return d[v]; } int main() { std::cin \u003e\u003e n \u003e\u003e v; for (int i = 1; i \u003c= n; i++) std::cin \u003e\u003e itemSpace[i] \u003e\u003e itemWeight[i]; std::cout \u003c\u003c SinglePack() \u003c\u003c std::endl; return 0; } ","date":"2021-08-11","objectID":"/pack-dp/:1:3","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"完全背包 和01背包类似，只是物品的数量变成了无限个。 由于物品由无限个，此时当前状态可以用于更新当前状态，因此将循环顺序改为从小到大即可。 ","date":"2021-08-11","objectID":"/pack-dp/:2:0","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"为什么不需要考虑物品的数量 显然，考虑物品的数量可以正确解决问题，但时间复杂度升至$O(NM^2)$，实在是太慢了。 如果第$i$个物品可以装$s_i$个，那么$f_{i, j}$和$f_{i, j - v_i}$可以这样转移: $$ f_{i, j} = \\max(f_{i - 1, j}, f_{i - 1, j - v_i} + w_i, f_{i - 1, j - 2v_i} + 2w_i, \\dots, f_{i - 1, j - s_i v_i} + s_i w_i) $$ $$ f_{i, j - v_i} = \\max(f_{i - 1, j - v_i}, f_{i - 1, j - 2v_i} + w_i, f_{i - 1, j - 3v_i} + 2w_i, \\dots, f_{i - 1, j - s_i v_i} + (s_i - 1)w_i) $$ 发现$f_{i, j - v_i} + w_i$其实就是$f_{i, j}$转移中$f_{i - 1, j}$后面所有项的最大值，因此转移方程简化如下： $$ f_{i, j} = \\max(f_{i - 1, j}, f_{i, j - v_i} + w_i) $$ 再应用上面提到的空间优化，得到下面的代码 #include \u003ciostream\u003e const int N = 1005, V = 1005; int n, v; int itemSpace[N], itemWeight[N]; int FullPack() { int d[N][V]; for (int i = 0; i \u003c N; i++) for (int j = 0; j \u003c V; j++) d[i][j] = 0; // subsets of d[i, j]: a. has i; b. without i (d[i - 1, j]). for (int i = 1; i \u003c= n; i++) { for (int j = itemSpace[i]; j \u003c= v; j++) { for (int k = 0; k * itemSpace[i] \u003c= j; k++) { d[i][j] = std::max(d[i][j], d[i][j - k * itemSpace[i]] + k * itemWeight[i]); } } } return d[n][v]; } int FullPackOptimized() { int d[N][V]; for (int i = 0; i \u003c N; i++) for (int j = 0; j \u003c V; j++) d[i][j] = 0; // subsets of d[i, j]: a. has i; b. without i (d[i - 1, j]). for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= v; j++) { d[i][j] = d[i - 1][j]; if (itemSpace[i] \u003c= j) d[i][j] = std::max(d[i][j], d[i][j - itemSpace[i]] + itemWeight[i]); } } return d[n][v]; } int FullPackFullOptimized() { int d[V]; for (int i = 0; i \u003c V; i++) d[i] = 0; // subsets of d[i, j]: a. has i; b. without i (d[i - 1, j]). for (int i = 1; i \u003c= n; i++) { for (int j = itemSpace[i]; j \u003c= v; j++) { d[j] = std::max(d[j], d[j - itemSpace[i]] + itemWeight[i]); } } return d[v]; } int main() { std::cin \u003e\u003e n \u003e\u003e v; for (int i = 1; i \u003c= n; i++) std::cin \u003e\u003e itemSpace[i] \u003e\u003e itemWeight[i]; std::cout \u003c\u003c FullPackOptimized() \u003c\u003c std::endl; return 0; } ","date":"2021-08-11","objectID":"/pack-dp/:2:1","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"多重背包 多重背包与完全背包类似，但限定了每种物品的数量。 首先这个问题可以用完全背包优化前的算法，但时间复杂度太高，我们可以考虑用二进制拼凑思想优化，即把多个物品合并成由2的非负整数次幂的几个物品组，然后做01背包，时间复杂度$O(M \\log N)$ 可以用优化完全背包的方式优化多重背包吗？我们尝试写出$f_{i, j}$到$f_{i, j - s_i v_ i}$的转移方程： $$ f_{i, j} = \\max(f_{i - 1, j}, f_{i - 1, j - v} + w, \\dots, f_{i - 1, j - s_i v_i} + s_i w_i) $$ $$ f_{i, j - v} = \\max(f_{i - 1, j - v}, f_{i - 1, j - 2v} + w, \\dots, f_{i - 1, j - (s_i + 1)v_i} + s_i w_i) $$ 发现$f_{i, j - v} + w$并不能像完全背包一样对齐，而是少了$f_{i - 1, j}$，多出了$f_{i - 1, j - (s_i + 1)v_i} + (s_i + 1)w_i$。以此类推，在不出边界的情况下，之后的$f_{i - 1, j - 2v}$直到$f_{i - 1, j - s_i v_i}$都是如此，就像是一个长度为$s$的窗口滑出。因此，要求每一个状态的最大值，只需要求它前面滑动窗口中状态的最大值。 要求滑动窗口的最大值，可以用单调队列。 ","date":"2021-08-11","objectID":"/pack-dp/:3:0","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"几个问题优化方式的联系 我们发现，完全背包和多重背包优化的关键都在于把一类数的特征由一个数或一个更快找出这个特征的数据结构中的数等价替换。 ","date":"2021-08-11","objectID":"/pack-dp/:4:0","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"背包问题简单变形 ","date":"2021-08-11","objectID":"/pack-dp/:5:0","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"多维费用 CH0206-4978-宠物小精灵之收服 这个题就是典型的二维费用的背包问题，状态定义只需要增加一维表示第二种费用。但本题要注意，“当皮卡丘的体力小于等于0时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服”，所以答案不是$f_{n, m}$而是$f_{n, m - 1}$，有些题库，包括我校校内题库，没有考虑这一点，导致正解不能AC。 AC代码： #include \u003ciostream\u003e const int N = 1005, M = 505; int n, m, k; int f[N][M]; int main() { std::cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for (int i = 1; i \u003c= k; i++) { int ball, hp; std::cin \u003e\u003e ball \u003e\u003e hp; for (int j = n; j \u003e= ball; j--) for (int t = m; t \u003e= hp; t--) f[j][t] = std::max(f[j][t], f[j - ball][t - hp] + 1); } std::cout \u003c\u003c f[n][m - 1] \u003c\u003c \" \"; for (int i = 0; i \u003c= m; i++) if (f[n][i] == f[n][m - 1]) { std::cout \u003c\u003c m - i \u003c\u003c std::endl; break; } return 0; } ","date":"2021-08-11","objectID":"/pack-dp/:5:1","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"多维价值 这个很少见，如果有要么考虑各种价值的优先级，要么考虑将多种价值转换为一种。 ","date":"2021-08-11","objectID":"/pack-dp/:5:2","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"分组背包 在01背包的基础上，将物品划为多个组，要求每组至多取一个物品，总价值的最大值。 要解决分组背包问题，只需要在状态定义中加一维，表示组数即可，但要注意控制循环层级，第一层为组数（可以看作物品，因为每组只选一个），第二层体积，第三层组中物品。 示例代码： #include \u003ciostream\u003e const int N = 105, V = 105, S = 105; int n, v, s[N]; int itemSpace[S][N], itemWeight[S][N]; int GroupPackOptimized() { int d[V]; for (int i = 0; i \u003c V; i++) d[i] = 0; // subsets of d[i, j]: a. has i; b. without i (d[i - 1, j]). for (int g = 1; g \u003c= n; g++) { for (int j = v; j \u003e= 0; j--) { for (int i = 0; i \u003c s[g]; i++) { if (itemSpace[g][i] \u003c= j) d[j] = std::max(d[j], d[j - itemSpace[g][i]] + itemWeight[g][i]); } } } return d[v]; } int main() { std::cin \u003e\u003e n \u003e\u003e v; for (int i = 1; i \u003c= n; i++) { std::cin \u003e\u003e s[i]; for (int j = 0; j \u003c s[i]; j++) { std::cin \u003e\u003e itemSpace[i][j] \u003e\u003e itemWeight[i][j]; } } std::cout \u003c\u003c GroupPackOptimized() \u003c\u003c std::endl; return 0; } ","date":"2021-08-11","objectID":"/pack-dp/:6:0","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["动态规划"],"content":"有依赖关系的背包问题 这类问题有些可以通过转化成为分组背包问题，有一些只能通过树形动态规划解决。下面这一题可以转化为分组背包问题： 洛谷-P1064-NOIP2006提高组 金明的预算方案 由于本题附件最多有两个，可以拆分成不同选法，放在一个组里。AC代码： #include \u003ciostream\u003e#include \u003cvector\u003e const int N = 65, M = 32005; struct Item { Item(int v, int w) : v(v), w(w) {} int v; int w; }; int m, n; std::vector\u003cItem\u003e items[N]; int f[M]; int main() { std::cin \u003e\u003e m \u003e\u003e n; int v, w, dep; for (int i = 1; i \u003c= n; i++) { std::cin \u003e\u003e v \u003e\u003e w \u003e\u003e dep; int len = items[dep].size(); if (dep == 0) items[i].push_back(Item(v, v * w)); else for (int j = 0; j \u003c len; j++) items[dep].push_back(Item(items[dep][j].v + v, items[dep][j].w + v * w)); } for (int i = 1; i \u003c= n; i++) for (int j = m; j \u003e= 0; j--) { int len = items[i].size(); for (int k = 0; k \u003c len; k++) if (j - items[i][k].v \u003e= 0) f[j] = std::max(f[j], f[j - items[i][k].v] + items[i][k].w); } std::cout \u003c\u003c f[m] \u003c\u003c std::endl; return 0; } 更复杂的情况需要考虑树形动态规划。 ","date":"2021-08-11","objectID":"/pack-dp/:7:0","tags":["动态规划"],"title":"背包问题","uri":"/pack-dp/"},{"categories":["misc"],"content":"过了一年多，重拾个人博客。尽管时间很紧张，事情一件件卷来，我还是希望用博客分享一些想法。 不定期更新，内容也没什么限定，希望可以给您愉悦的阅读感受。 ","date":"2021-06-06","objectID":"/hello-world/:0:0","tags":["misc"],"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"我的个人博客。 记录自己的学习和爱好。 ","date":"2021-06-06","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"}]